<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>多线程 | 胡大仙</title><meta name="author" content="huxianseng"><meta name="copyright" content="huxianseng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并行和并发有什么区别？  并发：两个及两个以上的线程在同一 时间段 内执行。 并行：两个及两个以上的线程在同一 时刻 执行。  最关键的点是：是否是 同时 执行。 线程与进程 线程和进程的区别？★★★ 进程：拥有资源（资源分配）的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元 线程：是 cpu 调度的基本单位，只拥有一些必不可少的资源（比如程序计数器）">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="http://hupingsheng.com/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="胡大仙">
<meta property="og:description" content="并行和并发有什么区别？  并发：两个及两个以上的线程在同一 时间段 内执行。 并行：两个及两个以上的线程在同一 时刻 执行。  最关键的点是：是否是 同时 执行。 线程与进程 线程和进程的区别？★★★ 进程：拥有资源（资源分配）的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元 线程：是 cpu 调度的基本单位，只拥有一些必不可少的资源（比如程序计数器）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hupingsheng.com/images/home.webp">
<meta property="article:published_time" content="2023-06-16T03:00:07.000Z">
<meta property="article:modified_time" content="2023-09-03T02:51:27.617Z">
<meta property="article:author" content="huxianseng">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hupingsheng.com/images/home.webp"><link rel="shortcut icon" href="/images/my_logo.png"><link rel="canonical" href="http://hupingsheng.com/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-03 10:51:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/home.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="胡大仙"><span class="site-name">胡大仙</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-16T03:00:07.000Z" title="发表于 2023-06-16 11:00:07">2023-06-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-03T02:51:27.617Z" title="更新于 2023-09-03 10:51:27">2023-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/">JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/">Java进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="并行和并发有什么区别？">并行和并发有什么区别？</h3>
<ul>
<li><strong>并发</strong>：两个及两个以上的线程在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的线程在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>
<h2 id="线程与进程">线程与进程</h2>
<h3 id="线程和进程的区别？★★★">线程和进程的区别？★★★</h3>
<p>进程：拥有资源（资源分配）的基本单位。一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元</p>
<p>线程：是 cpu 调度的基本单位，只拥有一些必不可少的资源（比如程序计数器），共享进程的全部资源，同一进程中的多个线程之间可以并发执行。同一进程的各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>协程是一种用户态的轻量级线程，一个线程可以拥有多个协程，协程调度完全由用户控制，协程也拥有自己的寄存器 上下文和栈。协程上下文切换非常快。 协程类似没有返回值的函数调用。</p>
</blockquote>
<h3 id="守护线程是什么？">守护线程是什么？</h3>
<p>守护线程（即 Daemon thread），是一种特殊的线程==为其他线程服务的==，在后台默默的完成一些系统性的服务，比如垃圾回收线程就是最典型的例子</p>
<blockquote>
<p>Java线程分为用户线程和守护线程</p>
<p>用户线程：自定义的线程,如new Thread()  默认的都是用户线程  是系统的工作线程，它会完成这个程序需要完成的业务操作</p>
<p>一般情况下不做特别说明配置，默认的都是<strong>用户线程</strong></p>
<p>守护线程作为一个服务线程，没有服务对象就会停止，系统可以退出。假如当前jvm只剩下守护线程的时候，就会直接退出。</p>
<p>setDaemon()必须会要在start之前设置，否则报异常。</p>
</blockquote>
<h3 id="创建线程的几种方式">创建线程的几种方式</h3>
<ol>
<li>
<p>继承 Thread 类创建线程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="comment">* 2.重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中</span></span><br><span class="line"><span class="comment">* 3.创建Thread类的子类的对象</span></span><br><span class="line"><span class="comment">* 4.通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.重run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//3.新建Thread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//4.调用start方法</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实现 Runnable 接口创建线程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="comment">* 2.实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line"><span class="comment">* 3.创建实现类的对象</span></span><br><span class="line"><span class="comment">* 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line"><span class="comment">* 5.通过Thread类的对象调用start()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">RunnableTest</span> <span class="variable">runnableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableTest);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开发中优先选择：实现Runnable接口的方式</p>
<p><strong>原因：</strong></p>
<ol>
<li>
<p>java不支持多继承</p>
<p>实现的方式没类的单继承性的局限性(java中一个类只能使用extends继承一个父类)</p>
</li>
<li>
<p>资源消耗</p>
<p>如果继承Thread，每开启一个线程，都要创建一个任务对象，因为对象和线程是一个类，消耗资源</p>
<p>而实现runnable接口，无论要开启多少个线程，只需要创建一个任务对象即可。</p>
</li>
<li>
<p>解耦</p>
<p>runnable的创建任务和启动任务是解耦的。线程任务（run方法）和开启新线程（start方法）不是必须对应的</p>
</li>
</ol>
<p>**联系：**public class Thread implements Runnable</p>
<p>**相同点：**两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p>
</blockquote>
</li>
<li>
<p>通过 Callable 和 Future 创建线程；</p>
<p>实现callable接口并实例化后，执行callable接口，可以获取一 个future对象，通过future对象的get方法可以获得返回值。结合线程池可以实现有返回值的多线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="comment">* 2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line"><span class="comment">* 3.创建Callable接口实现类的对象</span></span><br><span class="line"><span class="comment">* 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line"><span class="comment">* 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line"><span class="comment">* 6.获取Callable中call方法的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p>
<ol>
<li>call()可以返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ol>
</blockquote>
</li>
<li>
<p>通过线程池创建线程。</p>
</li>
</ol>
<h3 id="创建线程的底层原理">创建线程的底层原理</h3>
<ol>
<li>Thread.start()调用native的start0()</li>
<li>JVM通过pthread_create()创建一个系统内核线程</li>
<li>在内核线程的运行方法中，利用JavaCalls调用java线程的run()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java实际上是开启不了线程的，靠调用本地方法start0()来操作底层硬件的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();   <span class="comment">//调用start0()</span></span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;  <span class="comment">// start0()是一个native本地方法，底层是c++实现的</span></span><br></pre></td></tr></table></figure>
<h3 id="终止线程的四种方式">终止线程的四种方式</h3>
<p>1、正常运行结束</p>
<p>程序运行结束，线程自动结束。</p>
<p>2、使用自定义标志退出线程</p>
<p>定义一个volatile修饰的关键字，当关键字为true时，while循环退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSafe</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">exit</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!exit)&#123; </span><br><span class="line">            <span class="comment">//do something </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、interrupt结束线程</p>
<p>4、stop方法终止线程（不推荐，线程不安全）</p>
<p>​		不安全的主要是：thread.stop()调用之后，创建子线程的线程会抛出<code>ThreadDeatherror</code>的错误，并且会释放子线程所持有的所有锁。</p>
<p>而一般加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致该线程所持有的所有锁突然释放（不可控制），可能会导致被保护的数据呈现不一致的情况。</p>
<h3 id="wait和notifiy的虚假唤醒的产生原因及如何解决">wait和notifiy的虚假唤醒的产生原因及如何解决</h3>
<p><strong>什么是虚假唤醒</strong></p>
<p><strong>当一定的条件触发时会唤醒很多在阻塞态的线程，但只有部分的线程唤醒是有用的，其余线程的唤醒是多余的。</strong><br>
比如说卖货，如果本来没有货物，突然进了一件货物，这时所有的顾客都被通知了，但是只能一个人买，所以其他人都是无用的通知。</p>
<p><strong>导致虚假唤醒的原因</strong></p>
<p>主要就是一个线程直接在if代码块中被唤醒了，这时<strong>它已经跳过了if判断</strong>。我们只需要将if判断改为while，这样线程就会被重复判断而不再会跳出判断代码块，从而不会产生虚假唤醒这种情况了。</p>
<p>可以拿生产者消费者模型举例，商品超卖</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiA5Y-q5bCP6YC455m9,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<h3 id="线程的安全三大特性">线程的安全三大特性</h3>
<p><strong>可见性</strong></p>
<p>一个线程对变量进行的修改，另一个变量可以立刻看到修改。可以通过volatile，synchronized，lock来进行限制</p>
<p><strong>原子性</strong></p>
<p>一个操作是不可中断的，要么成功，要么失败。由于线程之间的切换，导致了原子性问题。<strong>常见的num++就是非原子性的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令 <span class="number">1</span>：把变量 num从内存加载到 CPU 的寄存器</span><br><span class="line">指令 <span class="number">2</span>：在寄存器中执行 num + <span class="number">1</span> 操作</span><br><span class="line">指令 <span class="number">3</span>：+<span class="number">1</span> 后的结果写入 CPU 缓存 或 内存</span><br></pre></td></tr></table></figure>
<p>可以通过synchronized，lock来进行限制</p>
<p><strong>有序性</strong></p>
<p>防止指令的代码重排序。使实际的执行顺序按照代码的执行顺序执行。可以通过volatile关键字、 synchronized、 Lock接口</p>
<h3 id="Java多线程优先级？">Java多线程优先级？</h3>
<p>默认优先级是5，提供了1，5，10三档的优先级。通过getpriority和setpriority方法可以设置和得到具体的优先级。 即使线程的优先级很低，仍然可以执行。cpu分配资源，在控制台上并不能看出，而且，优先级低的并不代表一定要等到优先级高的运行完才能运行，只是cpu分配的资源少了而已。</p>
<h3 id="Runnable-和-Callable-有什么区别？">Runnable 和 Callable 有什么区别？</h3>
<ol>
<li>Runnable 接口中的 run() 方法的<strong>返回值是 void</strong>，它做的事情只是纯粹地去执行 run() 方法中的代码而已；</li>
<li>Callable 接口中的 call() 方法是<strong>有返回值的</strong>，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。</li>
</ol>
<h3 id="操作系统线程状态及转换？（生命周期-5种）★★★">操作系统线程状态及转换？（生命周期 5种）★★★</h3>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160040497.png" alt="image-20230902160040497"></p>
<ul>
<li>
<p>新建：当一个 Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p>
</li>
<li>
<p>就绪：处于新建状态的线程被star()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</p>
</li>
<li>
<p>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能</p>
</li>
<li>
<p>阻塞：在某种特殊情况下，被人为挂起（sleep）或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态</p>
</li>
<li>
<p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p>
</li>
</ul>
<h3 id="Java线程的状态及转换（6种）【生命周期】">Java线程的状态及转换（6种）【生命周期】</h3>
<p>jdk1.5之后就变成6种状态了，以这个为准。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/summerday152/p/12288671.html">线程状态及其转换</a></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230822001042971.png" alt="image-20230822001042971"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.State 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NEW,               <span class="comment">//新建</span></span><br><span class="line">    RUNNABLE,          <span class="comment">//可运行</span></span><br><span class="line">    BLOCKED,            <span class="comment">//阻塞</span></span><br><span class="line">    WAITING,           <span class="comment">//等待</span></span><br><span class="line">    TIMED_WAITING,     <span class="comment">//超时等待</span></span><br><span class="line">    TERMINATED;        <span class="comment">//终止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="新建状态（NEW）"><strong>新建状态（NEW）</strong></h3>
</li>
</ul>
<p>即用<strong>new关键字</strong>新建一个线程，这个线程就处于<strong>新建状态</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testStateNew</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;&#125;);</span><br><span class="line">    System.out.println(thread.getState()); <span class="comment">// 输出 NEW </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，只是创建了线程而并没有调用start()方法，此时线程处于NEW状态。</p>
<ul>
<li>
<h3 id="运行状态（RUNNABLE）"><strong>运行状态（RUNNABLE）</strong></h3>
<p>操作系统中的<code>READY</code>和<code>RUNNING</code>两种状态，在Java中统称为RUNNABLE。</p>
<p>在调用start()方法之后，线程就进入RUNNABLE状态。其中RUNNABLE状态包含READY状态和RUNNING状态。理论上刚进入RUNNABLE状态的线程，都会是READY状态，存储在一个就绪队列中，等待着被操作系统的调度机制选到，进入 CPU 中运行</p>
<p><strong>READY</strong></p>
<p>当线程对象调用了<code>start()</code>方法之后，线程处于<strong>就绪状态</strong>，就绪意味着该线程<strong>可以执行</strong>，但具体啥时候执行将取决于操作系统线程调度器的调度。</p>
<ul>
<li>不允许对一个线程多次使用start。</li>
<li>线程执行完成之后，不能试图用start将其唤醒。</li>
</ul>
<p><strong>RUNNING</strong></p>
<p>处于就绪状态的线程获得了CPU之后，<strong>真正开始执行run()方法的线程执行体时</strong>，意味着该线程就已经处于<strong>运行状态</strong>。需要注意的是，<strong>对于单处理器，一个时刻只能有一个线程处于Running状态。</strong></p>
</li>
<li>
<h3 id="终止（TERMINATED）">终止（TERMINATED）</h3>
<p>即<strong>线程的终止</strong>，表示线程已经执行完毕。已经消亡的线程不能通过start再次唤醒，否则会抛异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<h3 id="阻塞状态（BLOCKED）"><strong>阻塞状态（BLOCKED）</strong></h3>
<p>多个线程抢一把锁，只有一个线程抢到锁了，其他线程这进入BLOCKED状态。阻塞状态表示线程<strong>正等待锁</strong>，而陷入的状态。</p>
<p>以下场景线程将会阻塞：</p>
<ul>
<li>线程等待进入synchronized同步方法。</li>
<li>线程等待进入synchronized同步代码块。</li>
</ul>
</li>
<li>
<h3 id="等待状态（WAITING）">等待状态（WAITING）</h3>
<ol>
<li>
<p>获取锁的线程，执行<code>wait()</code>方法，主动释放锁，那么此时该线程变成waiting状态，该线程也进入对象锁的等待队列（等下次别的线程唤醒后再抢锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">       ...</span><br><span class="line">       lock.wait();</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当执行到 <code>t.join() </code>(插入)的时候，主线程会变成 WAITING 状态，直到线程 t 执行完毕，主线程才会变回 RUNNABLE 状态，继续往下执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(...);</span><br><span class="line">  t.start();</span><br><span class="line">  t.join();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看Thread.join()源码，会发现本质还是调用了wait方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"><span class="comment">// 无参的 join 有用的信息就这些，省略了额外分支</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么指向join的线程是怎么唤醒的呢？实际上是线程结束后，会自动调用自己的 notifyAll()，无需程序员手动唤醒。</p>
</li>
</ol>
</li>
<li>
<h3 id="等待超时（TIMED-WAITING）">等待超时（TIMED_WAITING）</h3>
<p>相对于进入WAITING状态，进入TIMED_WAITING状态的线程，除了通过之前的唤醒方式，还可以通过设置超时时间，返回 RUNNABLE 状态。</p>
<p>需要注意的是，还有一个方法，仅仅让线程挂起，只能通过等待超时时间到了再被唤醒。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">线程状态</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NEW</td>
<td style="text-align:left">尚未启动的线程状态，即线程创建，<strong>还未调用start方法</strong></td>
</tr>
<tr>
<td style="text-align:left">RUNNABLE</td>
<td style="text-align:left"><strong>就绪状态</strong>（调用start，等待调度）+<strong>正在运行</strong></td>
</tr>
<tr>
<td style="text-align:left">BLOCKED</td>
<td style="text-align:left"><strong>等待监视器锁</strong>时，陷入阻塞状态</td>
</tr>
<tr>
<td style="text-align:left">WAITING</td>
<td style="text-align:left">等待状态的线程正在<strong>等待</strong>另一线程执行特定的操作（如notify）</td>
</tr>
<tr>
<td style="text-align:left">TIMED_WAITING</td>
<td style="text-align:left">具有<strong>指定等待时间</strong>的等待状态</td>
</tr>
<tr>
<td style="text-align:left">TERMINATED</td>
<td style="text-align:left">线程完成执行，<strong>终止状态</strong></td>
</tr>
</tbody>
</table>
<h3 id="sleep-和-wait-的异同？★">sleep() 和 wait() 的异同？★</h3>
<ul>
<li>
<p><strong>相同点</strong>：一旦执行方法，都可以暂停当前的线程</p>
</li>
<li>
<p><strong>不同点</strong>：</p>
<ol>
<li>
<p>来自不同的类：wait是Object类的方法，任何实例对象都能调用。sleep是Thread类的静态方法</p>
</li>
<li>
<p>关于锁的释放：wait会释放锁（隐含着需要先拥有锁）。sleep不会释放锁（可能拥有锁，也可能没有锁）</p>
</li>
<li>
<p>使用范围不同：wait()必须使用在同步代码块或同步方法中。sleep()可以在任何需要的场景下调用。</p>
</li>
</ol>
<blockquote>
<p>为什么wait必须在同步代码块中执行，是一个&quot;Lost wake-up problem&quot;问题</p>
</blockquote>
</li>
</ul>
<blockquote>
<h2 id="为什么-wait-方法不定义在-Thread-中？">为什么 wait() 方法不定义在 Thread 中？</h2>
<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
</blockquote>
<blockquote>
<p>关于wait(),notify（）</p>
<p>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</p>
<p>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</p>
<p>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
</blockquote>
<h3 id="线程的-run-和-start-有什么区别？">线程的 run() 和 start() 有什么区别？</h3>
<ol>
<li>当程序调用start()方法，将会创建一个新线程去执行run()方法中的代码。但是如果直接调用run()方法的话，会直接在当前线程中执行run()中的代码，注意，这里不会创建新线程。这样run()就像一个普通方法一样。</li>
<li>另外当一个线程启动之后，不能重复调用start()，否则会报illegalStateException异常。如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().</li>
<li>run方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li>
</ol>
<p><strong>总结</strong>：<strong>就是run()就是一个普通的方法，而start()会创建一个新线程去执行run()的代码。</strong></p>
<blockquote>
<p>为什么java多线程调用的是start方法不是run方法【原理性解释】</p>
<p>run方法只是简单的调用了实现类的run方法。没有进行任何多线程处理</p>
<p>start方法就不一样了，可以看到关键的代码就是<strong>start0</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">		...</span><br><span class="line">      <span class="built_in">this</span>.start0();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>start0是native方法，jvm的本地方法。start0会根据不同的系统实现不同的线程调度。jvm会根据不同的直接调用操作系统的线程管理</p>
<p>start()方法调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态。具体什么时候执行，取决于cpu，由cpu统一调度。</p>
<p>==java中真正实现多线程的是start中的start0()方法，run方法只是一个普通的方法==</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160121505.png" alt="image-20230902160121505"></p>
</blockquote>
<h3 id="在-Java-程序中怎么保证多线程的运行安全？">在 Java 程序中怎么保证多线程的运行安全？</h3>
<p>线程安全在三个方面体现：</p>
<p><strong>原子性</strong>：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic，synchronized）；</p>
<p><strong>可见性</strong>：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile）；</p>
<p><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。</p>
<h3 id="Java-线程同步的几种方法？★">Java 线程同步的几种方法？★</h3>
<ol>
<li>
<p><strong>同步代码块（使用 Synchronized 关键字）；</strong></p>
<p><strong>说明：</strong></p>
<ol>
<li>
<p>操作<strong>共享数据的代码</strong>，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。</p>
</li>
<li>
<p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</p>
</li>
<li>
<p>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//同步监视器就是需要同步线程的公共对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>要求多个线程必须要共用同一把锁。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>同步方法(使用 synchronized 关键字)</strong></p>
<p>有synchronized关键字修饰的方法。</p>
<p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，</p>
<p>内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String namer)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket3</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Lock锁 — JDK 5.0新增</strong></p>
<ul>
<li>
<p>从JDK 5.0开始，Java提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p>
</li>
<li>
<p>java.util.concurrent.locks**.Lock接口**是控制多个线程对共享资源进行访问的工具。<strong>锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</strong></p>
</li>
<li>
<p><strong><code>ReentrantLock</code>类实现了<code>Lock</code></strong>，具体使用的是lock的子类<code>ReentrantLock</code>，拥有与 synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是<code>Reentrantlock</code>，<strong>可以显式加锁、释放锁</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReenTrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLook</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock<span class="comment">//2.先加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程同步的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//3.后解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用特殊域变量 volatile 实现线程同步；</p>
</li>
<li>
<p>使用阻塞队列实现线程同步；</p>
<p>LinkedBlockingQueue 类常用方法<br>
LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue<br>
put(E e) : 在队尾添加一个元素，如果队列满则阻塞<br>
size() : 返回队列中的元素个数<br>
take() : 移除并返回队头元素，如果队列空则阻塞</p>
</li>
<li>
<p>使用信号量 Semaphore。</p>
</li>
</ol>
<h3 id="多线程的join方法">多线程的join方法</h3>
<p>join方法用于线程间的同步，将线程的并行执行转为串行执行。</p>
<p>比如：在main线程中调用join，会使得main线程进入等待状态，等join线程执行完毕后，main线程会继续执行，join方法必须在start方法之后，如果说有两个线程start，再执行 join，彼此之间不会相互影响。只有main线程被阻塞了。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moonandstar08/p/4931625.html">https://www.cnblogs.com/moonandstar08/p/4931625.html</a></p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160131626.png" alt="image-20230902160131626"></p>
<h2 id="乐观锁与悲观锁">乐观锁与悲观锁</h2>
<h3 id="说下对悲观锁和乐观锁的理解？">说下对悲观锁和乐观锁的理解？</h3>
<p><strong>悲观锁：</strong></p>
<p>认为自己在使用数据的时候==一定有别的线程来修改数据==，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。传统的关系型数据库里边就用到了很多这种锁机制，比如：行锁、表锁、读锁、写锁等，都是在做操作之前先上锁。<strong>Java 中 synchronized关键字 和 Lock的实现类就是悲观锁</strong></p>
<p><strong>乐观锁：</strong></p>
<p>认为自己在使用数据时==不会有别的线程修改数据或资源==，所以不会添加锁</p>
<p>在Java中是通过==无锁编程==来实现的，只是在<strong>更新数据的时候去判断</strong>，之前有没有别的线程去更新了这个数据。</p>
<p>如果这个数据没有被更新，当前线程将自己修改的数据成功写入</p>
<p>如果这个数据已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如<strong>放弃修改、重试抢锁</strong>等等</p>
<p><strong>- 判断规则</strong></p>
<ol>
<li>版本号机制Version</li>
<li>==最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的==</li>
</ol>
<p><strong>两种锁的使用场景</strong></p>
<p>适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。—得之我幸，不得我命</p>
<h3 id="乐观锁常见的两种实现方式是什么？">乐观锁常见的两种实现方式是什么？</h3>
<ul>
<li>
<p><strong>版本号机制</strong></p>
<p>一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。</p>
</li>
<li>
<p><strong>CAS 算法</strong></p>
<p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：<strong>VEN</strong></p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p>
<p>所以这里的<strong>预期值E本质上指的是“旧值”</strong>。</p>
<p>我们以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是V，5就是E，6就是N。</p>
<p>那有没有可能我在判断了<code>i</code>为5之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为<strong>CAS是一种原子操作</strong>，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p>
<p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试【重试就是自旋】，当然也允许失败的线程放弃操作。</strong></p>
</li>
</ul>
<h3 id="悲观锁的常见的实现方式">悲观锁的常见的实现方式</h3>
<p>悲观锁的实现方式是加锁，</p>
<ul>
<li>
<p>加锁既可以是对代码块加锁（如Java的synchronized关键字），</p>
</li>
<li>
<p>也可以是对数据加锁（如MySQL中的排它锁）。</p>
</li>
</ul>
<h3 id="CAS与Synchronized的使用情景">CAS与Synchronized的使用情景?</h3>
<p>1、对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核 态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较 少，因此可以获得更高的性能。</p>
<p>2、对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于 synchronized。</p>
<h3 id="什么是自旋锁">什么是自旋锁</h3>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果<strong>物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</strong></p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋【让cpu做无用功】，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是==自旋锁==。</p>
<p>优点：</p>
<p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且<strong>占用锁时间非常短的代码块</strong>来说<strong>性能能大幅度的提升</strong>，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>缺点：</p>
<p>如果锁的竞争激烈，或者<strong>持有锁的线程需要长时间占用锁执行同步块</strong>，这时候就不适合 使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁；</p>
<h3 id="多线程会遇到什么问题">多线程会遇到什么问题</h3>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160141463.png" alt="image-20230902160141463"></p>
<h3 id="线程间的通信方式">线程间的通信方式</h3>
<ul>
<li>volatile 关键词修饰变量，保证所有线程对变量访问的可见性。</li>
<li>synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。</li>
<li>wait/notify方法</li>
<li>IO通信</li>
</ul>
<ol>
<li>
<p><strong>volatile和synchronized关键字</strong></p>
<p>volatile关键字保证了共享变量的可见性，任何线程需要读取时都要到内存中读 取（确保获得最新值）。synchronized关键字确保只能同时有一个线程访问方法或者变量，保证了线程访问的 可见性和排他性。 synchronized底层是基于监视器（Monitor）的获取，每个对象都有自己的监视器，线程必须获得监视器才能继续执行内容。</p>
</li>
<li>
<p><strong>wait notify机制</strong></p>
<p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B 调用了 对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而 执行后续操作。上述两 个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的 关系就如同开关信号一样，用来完成等 待方和通知方之间的交互工作（注意此机制要和锁一起使用，调用notify的线程执行完后释放了锁新唤醒线程才 能运行）。</p>
</li>
<li>
<p><strong>join()方法</strong></p>
<p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才 从 thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时 时间里没有终止，那么 将会从该超时方法中返回。 每个线程终止的前提是前驱线程的终止，每个线程等待前驱线程终止后，才从join() 方法返回，这里涉及了等待/通知机制（等待前驱线程结束，接收前驱线程结束通知）。</p>
</li>
<li>
<p><strong>ThreadLocal()方法 ThreadLocal</strong></p>
<p>即线程本地变量（每个线程都有自己唯一的一个哦），每个线程只能访问自己的，底层是一个ThreadLocalMap来存储信息，以ThreadLocal对象为键、任意对象为值，key是弱引用， value是强引用，所以使用完毕后要及时清理(尤其使用线程池时)</p>
</li>
</ol>
<h3 id="线程（Thread）的基本方法">线程（Thread）的基本方法</h3>
<p><strong>Thread静态方法</strong></p>
<ol>
<li>Thread.sleep(misseconeds) 睡眠：当前线程暂停一段时间让给别的线程去运行。Sleep复活时间，根据你传入 的睡眠时间而定，等到睡眠到规定的时间后，线程自动复活，它不会释放锁资源。</li>
<li>Thread.yield（） 让当前正在执行线程停下来一下，把执行机会让给别的在等待的线程，自己回到等待的就绪队列里面，自己也有可能会运行到，但更大的机会是让别的等待线程运行，相当于将自己的优先级暂时降低一 下，把机会让给别人一会儿。</li>
</ol>
<p><strong>Thread实例方法</strong></p>
<ol>
<li>
<p>start方法</p>
<p>线程创建以后，并不会自动运行，需要我们手动的start，将线程的状态设为就绪状态，但不一定马上就被运行，得等 到CPU分配时间片以后，才会运行。</p>
</li>
<li>
<p>join方法</p>
<p>join方法，意思就是在自己当前线程加入你调用的线程，本线程则等待，<strong>当调用Join的线程运行完了后，自己再去运行</strong>，t1和t2两个线程，如果在t1线程里面调用了t2.join()，则t1线程会进行等待状态，t2运行结束以后，才会继续运行 t1。这样可以保证线程的先后顺序。</p>
</li>
<li>
<p>wait方法(wait notify notifyAll都必须在持有有锁的代码中)</p>
<p>wait()是使当前线程阻塞，前提是必须先获得锁，一般配合到synchronized来使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法，wait方法由当前所有的local对象里面调用，this.wait(),必须被try catch包围，保证即使异常中断也可以使wait等待的线程唤醒。执行了wait方法，需要被别的线程通过同一个对象的 notify方法唤醒。</p>
</li>
<li>
<p>notify notifyAll</p>
<p>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完 synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。也就是说，notify/notifyAll()的执行只是唤醒沉睡的 线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后 立即退出临界区，以唤醒其他线程让其获得锁 notify 与 notifyAll区别 notify方法只唤醒一个等待（对象的）线程并 使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作 系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统 的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll方法。比如在生产者-消费者里面的使用，每次都 需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p>
</li>
<li>
<p>yeild（不会释放锁资源，而让当前线程从运行状态回到就绪状态）</p>
<p>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁 但是 yield不能立刻交出CPU，会出现同一个线程一直执行的情况，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。 注意调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重 新获取CPU执行时间，这一点是和sleep方法不一样的。</p>
</li>
</ol>
<h3 id="为什么说线程的上下文切换效率不高">为什么说线程的上下文切换效率不高</h3>
<p>线程在执行过程中<strong>会有自己的运行条件和状态（也称上下文）</strong>，比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候**恢复现场。**并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="引起CPU进行上下文切换的原因">引起CPU进行上下文切换的原因</h3>
<ul>
<li><strong>主动让出 CPU</strong>，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li><strong>时间片用完</strong>，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
</ul>
<h3 id="JVM的线程调度">JVM的线程调度</h3>
<p>1、<strong>协同式</strong> 线程的执行时间由线程本身控制 线程把自己的工作执行完 之后 主动通知系统切换到另一个线程上去 协同式多线程的最大好处是实现了简单 线程要把自己的事情干完之后才会进行线程的切换</p>
<p>切换线程操作对线程自己是可知的 所以一般没有线程同步的问题</p>
<p>缺点：线程执行时间不可控 如果一个线程的代码编写有问题 一直不告知系统进行线程切换 那么程序就会一直阻塞在 那里 想当不稳定 只要有一个进程坚持不让处理器执行时间 就可能回导致整个系统崩溃</p>
<p>2、<strong>抢占式</strong> 每个线程将由系统来分配执行时间 线程的切换不由线程本身来决定</p>
<p>java中有Thread::yiled() 方法主动让出执行时间</p>
<p>如果想要主动获取执行时间 线程本身是没有什么办法</p>
<p>线程的执行时间是系统可控的 也不会有一个线程导致真个进程甚至整个系统阻塞的问题</p>
<h3 id="线程什么时候主动放弃CPU">线程什么时候主动放弃CPU</h3>
<ol>
<li>
<p>Thread.sleep()</p>
<p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继 续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其 他被同步锁挡住了的线程也无法得到执行。</p>
<p>在多线程争用的情况，拥有锁的线程进行一些耗时操作，会极大降低吞吐量(amdahl定律)，如果在同步块中使用 sleep就是一种糟糕的做法，它不会释放锁却阻止其他线程获得锁。</p>
</li>
<li>
<p>Thread.yield()</p>
<p>yeild是个native静态方法，这个方法是想把自己占有的cpu时间释放掉，然后和其他线程一起竞争(注意yeild的线程 还是有可能争夺到cpu，注意与sleep区别)。在javadoc中也说明了，yeild是个基本不会用到的方法，一般在debug和 test中使用。</p>
</li>
<li>
<p>Object.wait()</p>
<p>wait会把当前的锁释放掉同时阻塞住，让出CPU；当别的线程调用该 Object 的 notify/notifyAll 之后，有可能得到 CPU，同时重新获得锁。</p>
<p>当然同样的condition.await(); 也会释放锁并且让出CPU；</p>
<p>当然很多竞争锁失败的线程最终也会阻塞住，但是这不是主动让出CPU，不在讨论范围内。</p>
</li>
<li>
<p>Thread.stop();太过暴力，不推荐使用，同时会释放所有锁。容易导致数据不一致。</p>
</li>
</ol>
<h2 id="JMM">JMM</h2>
<h3 id="什么是JMM">什么是JMM</h3>
<p>JMM(Java内存模型)本身是抽象的概念并不是真实存在的，它仅仅描述的是<strong>一组约定或规范</strong>，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式如何写入以及如何对另一个线程变成可见的，关键技术点是围绕<strong>多线程的原子性，可见性，有序性展开的</strong></p>
<h3 id="JMM三大特性">JMM三大特性</h3>
<h3 id="happen-before先行发生原则">happen-before先行发生原则</h3>
<h2 id="volatile-关键字">volatile 关键字</h2>
<h3 id="介绍一下volatile">介绍一下volatile</h3>
<p><strong>可见性</strong></p>
<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160151231.png" alt="image-20230902160151231"></p>
<p><strong>禁止指令重排</strong></p>
<p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行<strong>读写操作</strong>的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<blockquote>
<p><strong>什么是指令重排</strong></p>
<p>计算机在执行程序时，为了提高性能，编译器和处理器一般会进行指令重排，一般分为以下三种：</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160201813.png" alt="image-20230902160201813"></p>
<p>指令重排有以下三个特点:</p>
<ol>
<li>单线程环境下指令重排后可以保证与顺序执行指令的结果一致(就是不进行指令重排的情况）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//原来的执行顺序</span></span><br><span class="line">&gt;a = <span class="number">1</span></span><br><span class="line">&gt;b = <span class="number">0</span></span><br><span class="line">&gt;<span class="comment">//进行指令重排后执行</span></span><br><span class="line">&gt;b = <span class="number">0</span></span><br><span class="line">&gt;a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这两个顺序执行的指令结果都是a=1,b=0</p>
<ol start="2">
<li>进行指令重排的时候要考虑指令之间的数据依赖性(某个指令的数据需要根据另一个指令的数据获得)</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来的顺序</span></span><br><span class="line">a = <span class="number">0</span>;        <span class="comment">//指令1</span></span><br><span class="line">a = <span class="number">10</span>;       <span class="comment">//指令2</span></span><br><span class="line">b = a + <span class="number">1</span>;   <span class="comment">//指令3</span></span><br><span class="line"><span class="comment">//重排</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = a + <span class="number">1</span>;</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>此时两种顺序输出的结果就不一样了，这是因为指令3的数据依赖于指令2,单线程环境下指令重排不会出现这种情况。</li>
</ol>
<p><strong>为什么指令重排能够提高性能</strong></p>
<p>串行的代码确实会按代码语意正确的执行（就是编写的代码的运行逻辑），但是<strong>编译器对于代码本身的优化却并不一定会按实际的代码一步一步的执行</strong>,就比如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; #指令<span class="number">1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; #指令<span class="number">2</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>代码的执行过程一定是是int a=10然后int b=20,但是代码转换成计算机可以识别的指令可能是指令2，指令1。</p>
<p>【计组知识】</p>
<p>我们知道指令的执行可以分为这几步：</p>
<ul>
<li>取址 IF</li>
<li>译码和取寄存器操作数 ID</li>
<li>执行或者有效地址计算 EX (ALU逻辑计算单元)</li>
<li>存储器访问 MEM</li>
<li>写回 WB (寄存器)</li>
</ul>
<p>一段代码并不是由单条指令就可以执行完毕的，而是通过流水线技术来执行多条指令。</p>
<p>流水线技术是一种将指令分解为多步，<strong>并让不同指令的各步操作重叠</strong>，从而实现几条指令<strong>并行处理</strong>,这样就提高了指令的执行速度</p>
<p>简单来说就是<strong>通过指令重排,可以使用流水线技术实现指令的细分，然后实现几条指令的并行处理，从而提高速度。</strong></p>
<p><strong>volatile如何防止了指令重排</strong> ★</p>
<p>这就涉及到一个概念内存屏障（内存栅栏）,它是一个cpu指令,有两个作用:</p>
<ul>
<li>保证某些特定操作的执行顺序</li>
<li>保证某些变量的内存可见性(实现了volatile保证可见性)</li>
</ul>
<p>编译器和处理器都可以进行指令重排，那么如果我们在程序中插入一条Memery Barrier(内存屏障),那么就会告诉编 译器和cpu不能对这条指令进行重排，也就是说通过插入内存屏障，使屏障前后的指令不会进行重排优化,内存屏障还 可以强制刷出cpu的缓存，因此cpu上的线程都能读到这些数据的最新版本。</p>
<p>简单来说就是插入内存屏障后告诉cpu和编译器,这个内存屏障前后的指令你不要给我进行重排序</p>
<p>内存屏障分为四种： S</p>
<p>toreStore屏障、StoreLoad屏障、LoadLoad屏障、LoadStore屏障。</p>
<ul>
<li>Load相当于读屏障</li>
<li>Store相当于写屏障</li>
</ul>
</blockquote>
<p><strong>不具备原子性</strong></p>
<p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p>
<p><strong>分析</strong></p>
<p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p>
<p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500=2500。</p>
<p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p>
<ol>
<li>读取 inc 的值。</li>
<li>对 inc 加 1。</li>
<li>将 inc 的值写回内存。</li>
</ol>
<p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p>
<ol>
<li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
<li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li>
</ol>
<p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p>
<p><strong>改进</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrantLock </span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="synchronized-关键字">synchronized 关键字</h2>
<h3 id="说一说自己对于-synchronized-关键字的了解？">说一说自己对于 synchronized 关键字的了解？</h3>
<ul>
<li>
<p>在 Java 中，关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，</p>
</li>
<li>
<p>同时我们还应该注意到 synchronized 另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代 Volatile 功能）。</p>
</li>
</ul>
<h3 id="如何使用-synchronized-关键字？（三种应用方式）">如何使用 synchronized 关键字？（三种应用方式）</h3>
<p>synchronized 关键字最主要的三种使用方式：</p>
<p>同步方法（非静态方法，静态方法），同步代码块</p>
<ol>
<li>
<p><strong>修饰实例方法</strong>（锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>修饰静态方法</strong>（锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？</p>
<p>不互斥！</p>
<p>如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
</blockquote>
</li>
<li>
<p><strong>修饰代码块</strong>（锁指定对象/类）</p>
<p>对括号里指定的对象/类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this,当前实例对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(AccountingSync.class)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="谈谈-synchronized-和-ReenTrantLock-的区别？">谈谈 synchronized 和 ReenTrantLock 的区别？</h3>
<p>相同：</p>
<p>二者都可以解决线程安全问题</p>
<p>不同：</p>
<ol>
<li>
<p>synchronized 是和 for、while 一样的<code>关键字</code>，<code>ReentrantLock</code> 是<code>类</code>，这是二者的本质区别。</p>
</li>
<li>
<p>synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</p>
</li>
<li>
<p>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReenTrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLook</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">()</span>&#123;</span><br><span class="line">        lock.lock<span class="comment">//2.先加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程同步的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//3.后解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span></span><br></pre></td></tr></table></figure>
<h3 id="synchronized和lock的区别">synchronized和lock的区别</h3>
<p>1、lock是一个接口（jdk1.t的JUC包里面的），synchronized是一个关键字。</p>
<p>2、如果发生异常的synchronized会自动释放所有锁。lock不会，lock只有unlock才能释放锁。</p>
<p>3、synchronized无法判断锁的状态。lock的一些子类可以进行判断。 ReentrantLock的toString()方法可以返回锁状态</p>
<p>4、lock可以提供打断来中断锁。synchronized不能。</p>
<p>5、synchronized是一个重量级操作。lock是轻量级的。</p>
<p>6、两者都是可重入锁，但是synchronized是非公平锁，lock可以是公平也可以是非公平。</p>
<blockquote>
<p>synchronized的不足</p>
<ul>
<li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li>
<li>synchronized无法知道线程有没有成功获取到锁</li>
<li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>
</ul>
<p>这些问题lock都是可以解决的</p>
</blockquote>
<h3 id="synchronized的底层实现">synchronized的底层实现</h3>
<p>synchronized 关键字底层原理属于 JVM 层面。</p>
<p><strong>synchronized 同步语句块的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160211004.png" alt="image-20230902160211004"></p>
<p>从上面我们可以看出：<strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<a target="_blank" rel="noopener" href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp">ObjectMonitoropen in new window</a>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160217493.png" alt="image-20230902160217493"></p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160227963.png" alt="image-20230902160227963"></p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>synchronized 修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160237041.png" alt="image-20230902160237041"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<p><strong>总结：</strong></p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<blockquote>
<p><strong>简答版</strong></p>
<p>Java 对象底层都会关联一个 monitor【对象监视器】，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的<strong>唯一持有者</strong>，monitor 在被释放前不能再被其他线程获取。</p>
<p><strong>如何获取和释放monter</strong></p>
<p>synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。</p>
<p>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p>
</blockquote>
<h3 id="synchronized能否被打断，什么情况下打断">synchronized能否被打断，什么情况下打断</h3>
<p>已经获取到锁的能被中断，正在等待锁的不能被中断。</p>
<h3 id="synchronized修饰静态方法或者普通方法有啥区别？">synchronized修饰静态方法或者普通方法有啥区别？</h3>
<ul>
<li>
<p>synchronized关键字修饰普通方法时，获得的锁是对象锁，也就是this对应的实例，如果多个线程通过不同的对象来 调用方法，那么他们的锁就是不一样的，不会造成阻塞。</p>
</li>
<li>
<p>修饰静态方法时，锁是类锁，也就是类名.class，多个线程调用该类的同步的静态方法时，都会阻塞。</p>
</li>
</ul>
<h3 id="synchronized是可重入锁吗-作用">synchronized是可重入锁吗?作用?</h3>
<p>synchronized是可重入锁。</p>
<p>通俗来说：当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果 该锁是重入锁，请求就会成功，否则阻塞。 再换句话说：可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。</p>
<blockquote>
<p>什么是可重入锁？</p>
<p>若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序 不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入 并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行 时重新进入同一个子程序仍然是安全的。</p>
</blockquote>
<p>可重入锁的作用就是为了避免死锁，java中synchronized和ReentrantLock都是可重入锁</p>
<blockquote>
<p><strong>可重入锁最大的作用是避免死锁</strong></p>
<p>如下：两个方法同时被加锁，如果首先执行method1，则该线程拥有Test对象的锁，但如果synchronized不是可重入锁，当method1方法调用method2，发现method2需要等待method1锁释放，但是method1的执行又必须依赖method2，于是循环等待，形成死锁。</p>
<p>此时由于synchronized是可重入锁，method1调用method2方法时再次申请仍然可以得到Test对象的锁，避免了死锁问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="为什么wait和notify必须要在synchronized代码块使用？">为什么wait和notify必须要在synchronized代码块使用？</h3>
<p><a target="_blank" rel="noopener" href="https://muguang.me/it/2766.html">https://muguang.me/it/2766.html</a></p>
<p><strong>lost wake up 问题</strong></p>
<p>现在有一个生产者线程和消费者线程：<br>
先定义一个 obj 对象，并将其 count 属性的初始值设置为 0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.count++;</span><br><span class="line">obj.notify();</span><br></pre></td></tr></table></figure>
<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(obj.count&lt;=<span class="number">0</span>)</span><br><span class="line">    obj.wait();</span><br><span class="line">obj.count--;</span><br></pre></td></tr></table></figure>
<p>两个线程启动，消费者检查 <code>obj.count</code> 的值，发现 <code>obj.count &lt;= 0</code> 条件成立，但这时由于 CPU 的调度，发生上下文切换，生产者开始工作，执行了 <code>count+1</code> 和 <code>obj.notify()</code>，也就是发出通知，准备唤醒一个阻塞的线程。然后 CPU 调度到消费者，此时消费者开始执行 <code>obj.wait()</code>，线程进入阻塞。但生产者已经早在消费者阻塞前执行了唤醒动作，也就导致消费者永远无法醒来了。</p>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160246390.png" alt="image-20230902160246390"></p>
<p><strong>随便加个锁能解决「lost wake up 问题」吗</strong></p>
<p>不能，举个例子。</p>
<p>定义一把锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lock</span>();</span><br></pre></td></tr></table></figure>
<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">obj.count++;</span><br><span class="line">obj.notify();</span><br><span class="line">lock1.unlock();</span><br></pre></td></tr></table></figure>
<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line"><span class="keyword">while</span>(count&lt;=<span class="number">0</span>)</span><br><span class="line">    obj.wait();</span><br><span class="line">obj.count--;</span><br><span class="line">lock1.unlock();</span><br></pre></td></tr></table></figure>
<p>两个线程启动，<code>obj.count</code> 初始值为 0。假设消费者先竞争到锁，while 中的 <code>obj.count&lt;=0</code> 条件满足，执行 <code>obj.wait()</code> 使线程进入阻塞状态，lock1 锁没有被释放，所以生产者拿不到锁，也就无法 <code>obj.notify()</code> 通知消费者醒来，消费者将永远阻塞下去。</p>
<p><strong>Java 中什么锁才能解决「lost wake up 问题」</strong></p>
<p>只有上述例子中的 <strong>obj 对象锁才能避免这个问题</strong>，也就是将 <code>obj.wait()</code> 和 <code>obj.notify()</code> 放进 obj 对象锁的同步块中。如果锁的不是例子中的 obj 对象，Java 就会抛出 <code>IllegalMonitorStateException</code> 异常。</p>
<p>生产者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    obj.count++;</span><br><span class="line">    obj.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;=<span class="number">0</span>)</span><br><span class="line">       obj.wait();</span><br><span class="line">    obj.count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 中对 wait() 方法的注释中提到：线程在调用 <code>obj.wait()</code> 前必须要拿到当前 obj 对象的监视器 monitor 对象，即 obj 的锁。只有这样，当执行到 <code>obj.wait()</code> 时，该线程才可以暂时让出 obj 的同步锁并停止对锁的竞争，让其他正在等待此锁的线程可以得到同步锁并运行。</p>
<p>在上述例子中，消费者执行到 <code>obj.wait()</code> 时，让出了 obj 锁，停止了对锁的竞争，进入阻塞状态，紧接着生产者竞争到 obj 锁，执行了 <code>obj.notify()</code> 方法，唤醒了消费者，使消费者线程从阻塞状态重新回到就绪状态。</p>
<p>这里要注意的是，<code>obj.notify()</code> 并不是让生产者马上释放锁，也不是让消费者马上得到锁，而是通知消费者线程可以重新去参与锁的竞争了。</p>
<h3 id="可重入锁实现原理">可重入锁实现原理</h3>
<p>通过为每个锁关联一个请求计数器和一个获得该锁的线程。当计数器为0时，认为锁是未被占用的。线程请求一个未被占用的锁时，JVM将记录该线程并将请求计数器设置为1，此时该线程就获得了锁，当该线程再次请求这个锁，计数器将递增，当线程退出同步方法或者同步代码块时，计数器将递减，当计数器为0时，线程就释放了该对象，其他 线程才能获取该锁。</p>
<h3 id="常用的锁都有哪些，适用的场景">常用的锁都有哪些，适用的场景</h3>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160253373.png" alt="image-20230902160253373"></p>
<h3 id="Lock常用的实现类">Lock常用的实现类</h3>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160300861.png" alt="image-20230902160300861"></p>
<ul>
<li>
<p>Lock和ReadWriteLock是两大锁的根接口，</p>
<ul>
<li>
<p>Lock代表实现类是ReentrantLock（可重入锁），</p>
</li>
<li>
<p>ReadWriteLock（读写锁）的代表实现类是ReentrantReadWriteLock。 Lock 接口支持那些语义不同（重入、公平 等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现 是 ReentrantLock。 ReadWriteLock 接口以类似方式定义了一些读取者可以共享而写入者独占的锁。此包只提供了 一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用 于非标准要求的实现。</p>
</li>
</ul>
</li>
<li>
<p>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器 类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问 题，Condition 方法的名称与对应的 Object 版本中的不同。</p>
</li>
</ul>
<h3 id="Lock的实现方法">Lock的实现方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 如果当前线程未被中断，则获取锁，可以A.interrupt()方法中断等待</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 返回绑定到此 Lock 实例的新 Condition 实例</span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 仅在调用时锁为空闲状态才获取该锁，可以响应中断等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock的实现">ReentrantLock的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Semaphore信号量的使用</span><br><span class="line"></span><br><span class="line">信号量为**多线程协作**提供了更为强大的控制方法。广义上说，信号量是对锁的扩展。无论是内部锁<span class="keyword">synchronized</span>还是重入锁ReentrantLock，一次都只允许一个线程访问一个资源，而**信号量指定多个线程访问同一个资源**。 信号主要提供以下的构造函数</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span>;<span class="comment">//permits 指定信号量的准入数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>,<span class="type">boolean</span> fair)</span>;<span class="comment">//第二个参数指定是否公平</span></span><br></pre></td></tr></table></figure>
<p>在构造信号量时，必须指定信号量的准入数，即同时能申请多少许可，若一个线程每次只申请一个许可，这就相当于 指定了同时允许多少个线程能访问同一资源。 信号量的主要逻辑方法包括以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquireUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> timeout,TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>acquire()方法尝试获得一个准入的许可。若无法获得，线程会等待，直到有线程释放一个许可或者线程被中断。 acquireUninterruptibly()方法和acquire()方法类似，但是不能相应中断。tryacquire()尝试获得一个许可，成功返回 true失败返回false，他不会进行等待，立即返回。release()用于在线程访问资源结束后，释放一个许可，使其他线程 可以进行资源访问。 下面我们使用一个例子来演示信号量的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemapDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">final</span> Semaphore semp=<span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semp.acquire();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">&quot;:done!&quot;</span>);</span><br><span class="line">semp.release();</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ExecutorService exec=Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">final</span> SemapDemo demo=<span class="keyword">new</span> <span class="title class_">SemapDemo</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">exec.submit(demo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadWriteLock的整体实现">ReadWriteLock的整体实现</h3>
<p><strong>是什么？</strong></p>
<p>ReentrantReadWriteLock 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁：一个是用于读操作的 ReadLock，一个是用于写操作的 WriteLock。读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>
<p><strong>实现原理</strong></p>
<p>ReentrantReadWriteLock 基于 AQS 实现，它的自定义同步器（继承 AQS）需要在同步状态 state 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。ReentrantReadWriteLock 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p>
<h3 id="Lock的公平锁与非公平锁">Lock的公平锁与非公平锁</h3>
<p>ReentrantLock支持两种锁：<strong>公平锁</strong>和<strong>非公平锁</strong>。<strong>何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO</strong>。ReentrantLock的构造方法无参时是构造非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁</strong>。</p>
<h3 id="countdownLatch用法">countdownLatch用法</h3>
<p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要 等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能了。</p>
<h2 id="ThreadLocal">ThreadLocal</h2>
<h3 id="ThreadLocal原理">ThreadLocal原理</h3>
<p>ThreadLocal 就是一种以空间换时间的做法，在每个 Thread 里面维护了一个以开放定址法实现的 ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。 Thread对象内部有一个threadlocalmap成员变量，每一个Thread中维护了一个ThreadLocalMap成员变量（也称 threadLocals）。</p>
<h3 id="ThreadLocal用处">ThreadLocal用处</h3>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h3 id="ThreadLocal的内存泄漏问题以及如何避免">ThreadLocal的内存泄漏问题以及如何避免</h3>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h2 id="线程池">线程池</h2>
<h3 id="简述线程池">简述线程池</h3>
<p>没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。</p>
<p>线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。</p>
<p>将任务派发给线程池时，会出现以下几种情况</p>
<ul>
<li>核心线程池未满，创建一个新的线程执行任务。</li>
<li>如果核心线程池已满，工作队列未满，将线程存储在工作队列。</li>
<li>如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。</li>
<li>如果超过大小线程数，按照拒绝策略来处理任务。</li>
</ul>
<p>线程池参数：</p>
<ul>
<li>corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。</li>
<li>maximumPoolSize：线程池能够容纳同时执行的线程最大数。</li>
<li>keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。</li>
<li>workQueue：工作队列。</li>
<li>threadFactory：线程工厂，用来生产一组相同任务的线程。</li>
<li>handler：拒绝策略。</li>
</ul>
<p>拒绝策略有以下几种：</p>
<ul>
<li>AbortPolicy：丢弃任务并抛出异常</li>
<li>DiscardPolicy 表示直接抛弃当前任务但不抛出异常。</li>
<li>CallerRunsPolicy：重新尝试提交该任务</li>
<li>DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列</li>
</ul>
<h3 id="使用线程池的好处（为什么要用线程池）">使用线程池的好处（为什么要用线程池）</h3>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
<li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>
</ul>
<h3 id="线程池的原理">线程池的原理</h3>
<p>线程池做的工作主要是<strong>控制运行的线程的数量</strong>，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果 线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程。</strong></p>
<p>每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类 的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写Thread 类，在其 start 方法中添加不断 循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现 的，在获取下一个 Runnable 之前可以是阻塞的。</p>
<h3 id="线程池的构造参数">线程池的构造参数</h3>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160311224.png" alt="image-20230902160311224"></p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h3 id="线程池的拒绝策略">线程池的拒绝策略</h3>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h3 id="Java-线程池工作过程">Java 线程池工作过程</h3>
<p><strong>总结一下处理流程</strong></p>
<ol>
<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>
</ol>
<p><img src="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/image-20230902160317580.png" alt="image-20230902160317580"></p>
<h3 id="介绍一下常用的java的线程池">介绍一下常用的java的线程池</h3>
<ul>
<li>newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。</li>
<li>newFixedThreadPool 指定工作线程数量线程池。</li>
<li>newSingleThreadExecutor 单线程Executor。</li>
<li>newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。</li>
<li>newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。</li>
</ul>
<h2 id="Atomic-原子类">Atomic 原子类</h2>
<h3 id="简述常见的Atomic类">简述常见的Atomic类</h3>
<p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者–方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：</p>
<ul>
<li>AtomicInteger 原子更新整型</li>
<li>AtomicLong 原子更新长整型</li>
<li>AtomicBoolean 原子更新布尔类型</li>
</ul>
<p>Atomic数组类型有：</p>
<ul>
<li>AtomicIntegerArray 原子更新整型数组里的元素</li>
<li>AtomicLongArray 原子更新长整型数组里的元素</li>
<li>AtomicReferenceArray 原子更新引用类型数组里的元素。</li>
</ul>
<p>Atomic引用类型有：</p>
<ul>
<li>AtomicReference 原子更新引用类型</li>
<li>AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记</li>
<li>AtomicStampedReference 原子更新带有版本号的引用类型</li>
</ul>
<p>FieldUpdater类型：</p>
<ul>
<li>AtomicIntegerFieldUpdater 原子更新整型字段的更新器</li>
<li>AtomicLongFieldUpdater 原子更新长整型字段的更新器</li>
<li>AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器</li>
</ul>
<h3 id="简述Atomic类基本实现原理">简述Atomic类基本实现原理</h3>
<p>以AtomicIntger 为例。</p>
<p>方法getAndIncrement，以原子方式将当前的值加1，具体实现为：</p>
<ul>
<li>在 for 死循环中取得 AtomicInteger 里存储的数值</li>
<li>对 AtomicInteger 当前的值加 1</li>
<li>调用 compareAndSet 方法进行原子更新</li>
<li>先检查当前数值是否等于 expect</li>
<li>如果等于则说明当前值没有被其他线程修改，则将值更新为 next，</li>
<li>如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。</li>
</ul>
<h3 id="简述CountDownLatch">简述CountDownLatch</h3>
<p>CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。</p>
<h3 id="简述CyclicBarrier">简述CyclicBarrier</h3>
<p>CyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。</p>
<h3 id="简述Semaphore">简述Semaphore</h3>
<p>Semaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。</p>
<h3 id="简述Exchanger">简述Exchanger</h3>
<p>Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。</p>
<h2 id="AQS">AQS</h2>
<h3 id="什么是-AQS（抽象的队列同步器）">什么是 AQS（抽象的队列同步器）</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://hupingsheng.com">huxianseng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hupingsheng.com/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91/">http://hupingsheng.com/面试题/JavaSE/Java进阶/并发/并发/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hupingsheng.com" target="_blank">胡大仙</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/images/home.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88/" title="集合"><img class="cover" src="/images/home.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">集合</div></div></a></div><div class="next-post pull-right"><a href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" title="算法基础理论"><img class="cover" src="/images/home.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法基础理论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Java集合源码探究"><img class="cover" src="/images/home.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-16</div><div class="title">Java集合源码探究</div></div></a></div><div><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img class="cover" src="/images/home.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-16</div><div class="title">Java基础</div></div></a></div><div><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis/" title="redis"><img class="cover" src="/images/home.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-16</div><div class="title">redis</div></div></a></div><div><a href="/%E9%9D%A2%E8%AF%95%E9%A2%98/JavaSE/Java%E8%BF%9B%E9%98%B6/%E9%9B%86%E5%90%88/%E9%9B%86%E5%90%88/" title="集合"><img class="cover" src="/images/home.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-16</div><div class="title">集合</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">huxianseng</div><div class="author-info__description">日拱一卒，功不唐捐!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hupingsheng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hupingsheng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hu942658636@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">并行和并发有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">1.</span> <span class="toc-text">线程和进程的区别？★★★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">守护线程是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">创建线程的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">创建线程的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">终止线程的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%92%8Cnotifiy%E7%9A%84%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E7%9A%84%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">6.</span> <span class="toc-text">wait和notifiy的虚假唤醒的产生原因及如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">线程的安全三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">Java多线程优先级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runnable-%E5%92%8C-Callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">Runnable 和 Callable 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2%EF%BC%9F%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-5%E7%A7%8D%EF%BC%89%E2%98%85%E2%98%85%E2%98%85"><span class="toc-number">10.</span> <span class="toc-text">操作系统线程状态及转换？（生命周期 5种）★★★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2%EF%BC%886%E7%A7%8D%EF%BC%89%E3%80%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">Java线程的状态及转换（6种）【生命周期】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%8A%B6%E6%80%81%EF%BC%88NEW%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">新建状态（NEW）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%EF%BC%88RUNNABLE%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">运行状态（RUNNABLE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%EF%BC%88TERMINATED%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">终止（TERMINATED）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%EF%BC%88BLOCKED%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">阻塞状态（BLOCKED）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81%EF%BC%88WAITING%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">等待状态（WAITING）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%EF%BC%88TIMED-WAITING%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">等待超时（TIMED_WAITING）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F%E2%98%85"><span class="toc-number">18.</span> <span class="toc-text">sleep() 和 wait() 的异同？★</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8-Thread-%E4%B8%AD%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">为什么 wait() 方法不定义在 Thread 中？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">线程的 run() 和 start() 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">在 Java 程序中怎么保证多线程的运行安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%E2%98%85"><span class="toc-number">3.</span> <span class="toc-text">Java 线程同步的几种方法？★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84join%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">多线程的join方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number"></span> <span class="toc-text">乐观锁与悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E5%AF%B9%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">说下对悲观锁和乐观锁的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">乐观锁常见的两种实现方式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">悲观锁的常见的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%B8%8ESynchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">CAS与Synchronized的使用情景?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">什么是自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E9%81%87%E5%88%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">多线程会遇到什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">线程间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">线程（Thread）的基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%95%88%E7%8E%87%E4%B8%8D%E9%AB%98"><span class="toc-number">9.</span> <span class="toc-text">为什么说线程的上下文切换效率不高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7CPU%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.</span> <span class="toc-text">引起CPU进行上下文切换的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">11.</span> <span class="toc-text">JVM的线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%BB%E5%8A%A8%E6%94%BE%E5%BC%83CPU"><span class="toc-number">12.</span> <span class="toc-text">线程什么时候主动放弃CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JMM"><span class="toc-number"></span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJMM"><span class="toc-number">1.</span> <span class="toc-text">什么是JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">JMM三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happen-before%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="toc-number">3.</span> <span class="toc-text">happen-before先行发生原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number"></span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bvolatile"><span class="toc-number">1.</span> <span class="toc-text">介绍一下volatile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number"></span> <span class="toc-text">synchronized 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">说一说自己对于 synchronized 关键字的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9F%EF%BC%88%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">如何使用 synchronized 关键字？（三种应用方式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-synchronized-%E5%92%8C-ReenTrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">谈谈 synchronized 和 ReenTrantLock 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">synchronized和lock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">synchronized的底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E8%83%BD%E5%90%A6%E8%A2%AB%E6%89%93%E6%96%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%93%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">synchronized能否被打断，什么情况下打断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">synchronized修饰静态方法或者普通方法有啥区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%90%97-%E4%BD%9C%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">synchronized是可重入锁吗?作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wait%E5%92%8Cnotify%E5%BF%85%E9%A1%BB%E8%A6%81%E5%9C%A8synchronized%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">为什么wait和notify必须要在synchronized代码块使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">可重入锁实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">11.</span> <span class="toc-text">常用的锁都有哪些，适用的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">Lock常用的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">Lock的实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.</span> <span class="toc-text">ReentrantLock的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadWriteLock%E7%9A%84%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.</span> <span class="toc-text">ReadWriteLock的整体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">16.</span> <span class="toc-text">Lock的公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdownLatch%E7%94%A8%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">countdownLatch用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number"></span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">ThreadLocal原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%94%A8%E5%A4%84"><span class="toc-number">2.</span> <span class="toc-text">ThreadLocal用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal的内存泄漏问题以及如何避免</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number"></span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">简述线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">使用线程池的好处（为什么要用线程池）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">线程池的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">线程池的构造参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">5.</span> <span class="toc-text">线程池的拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Java 线程池工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">介绍一下常用的java的线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">Atomic 原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E5%B8%B8%E8%A7%81%E7%9A%84Atomic%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">简述常见的Atomic类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Atomic%E7%B1%BB%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">简述Atomic类基本实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0CountDownLatch"><span class="toc-number">3.</span> <span class="toc-text">简述CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0CyclicBarrier"><span class="toc-number">4.</span> <span class="toc-text">简述CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Semaphore"><span class="toc-number">5.</span> <span class="toc-text">简述Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Exchanger"><span class="toc-number">6.</span> <span class="toc-text">简述Exchanger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number"></span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AQS%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%9A%84%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">什么是 AQS（抽象的队列同步器）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法题"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法题"/></a><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法题">算法题</a><time datetime="2023-08-31T02:47:33.000Z" title="发表于 2023-08-31 10:47:33">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/RDB%E5%92%8CAOF/" title="Redis持久化"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis持久化"/></a><div class="content"><a class="title" href="/RDB%E5%92%8CAOF/" title="Redis持久化">Redis持久化</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JUC/" title="JUC学习笔记"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC学习笔记"/></a><div class="content"><a class="title" href="/JUC/" title="JUC学习笔记">JUC学习笔记</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2/" title="创建菜单和游戏界面"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建菜单和游戏界面"/></a><div class="content"><a class="title" href="/%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2/" title="创建菜单和游戏界面">创建菜单和游戏界面</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/" title="缓存更新方案"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存更新方案"/></a><div class="content"><a class="title" href="/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/" title="缓存更新方案">缓存更新方案</a><time datetime="2023-08-13T07:15:26.000Z" title="发表于 2023-08-13 15:15:26">2023-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By huxianseng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>