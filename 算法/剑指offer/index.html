<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>剑指offer | 胡大仙</title><meta name="author" content="huxianseng"><meta name="copyright" content="huxianseng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录剑指offer系列的刷题记录以及一些心得">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://hupingsheng.com/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/index.html">
<meta property="og:site_name" content="胡大仙">
<meta property="og:description" content="记录剑指offer系列的刷题记录以及一些心得">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hupingsheng.com/post_images/jianzhi-offer.jpg">
<meta property="article:published_time" content="2022-03-12T10:38:14.000Z">
<meta property="article:modified_time" content="2023-09-15T13:08:06.026Z">
<meta property="article:author" content="huxianseng">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hupingsheng.com/post_images/jianzhi-offer.jpg"><link rel="shortcut icon" href="/images/my_logo.png"><link rel="canonical" href="http://hupingsheng.com/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指offer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-15 21:08:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/post_images/jianzhi-offer.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="胡大仙"><span class="site-name">胡大仙</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指offer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-12T10:38:14.000Z" title="发表于 2022-03-12 18:38:14">2022-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-15T13:08:06.026Z" title="更新于 2023-09-15 21:08:06">2023-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指offer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="剑指-Offer-03-数组中重复的数字★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a>★</h3>
<blockquote>
<ol>
<li>
<p>排序法     时间o(nlogn)  空间o(1)</p>
</li>
<li>
<p>哈希表     时间o(n)  空间o(n)</p>
</li>
<li>
<p><strong>原地哈希</strong></p>
<p>题目中有说“所有数字都在 0～n-1 的范围内”，可以考虑<strong>下标法</strong>:通过不停交换元素，使得元素和它所对应的下标相等，即<code>nums[index]=index</code></p>
</li>
</ol>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img1618146573-bOieFQ-Picture0-16577252286952-16947774220673.png" alt="Picture0.png" style="zoom: 33%;">
<p>在数组的值对应索引的排序过程中，寻找一个索引对应多个值的矛盾情况，返回对应值即可</p>
<ol>
<li>
<p>对所有下标进行一遍遍历</p>
</li>
<li>
<p>若当前下标<code>index!=nums[index]</code>,则将<code>nums[index]</code>，换到<code>nums[nums[index]]</code>位置上</p>
</li>
<li>
<p>直到下标index上的数据等于index，所以用<code>while(index!=nums[index])</code></p>
</li>
</ol>
<p>时间复杂度O(N)，空间复杂度O(1)</p>
</blockquote>
<ol>
<li>
<p>排序法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.contains(num)) <span class="keyword">return</span> num;</span><br><span class="line">            dic.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下标法（原地哈希）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="comment">//不停的试图给i位置找到对应的数字，这个结果要不就是找到了，要不就是找到重复的数字</span></span><br><span class="line">            <span class="keyword">while</span>(i != nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    swap(nums[nums[i]],nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$，无额外空间使用，使用本身数字进行原地哈希</li>
</ul>
<h3 id="不修改数组找出重复的数"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/15/">不修改数组找出重复的数</a></h3>
<ul>
<li>给定一个长度为 n+1 的数组<code>nums</code>，数组中所有的数均在 1∼n1∼n 的范围内</li>
<li>数组中任意一个重复的数，但不能修改输入的数组</li>
</ul>
<blockquote>
<p>不修改数组，就无法使用排序的方法</p>
<p>n+1的大小数组放[1,n]范围内的数，[1,n]范围内的数值至少有一个是重复的。（抽屉原理）</p>
<p><strong>那么把[1,n]范围的数二分【按照数值划分，不是按照数组下标划分】，</strong></p>
<p>数组中数值属于【1，mid】的划为一组，数值属于【mid + 1, n】的划为一组。这样重复的至少属于一边</p>
<p>以此类推，最后二分为一个具体的数</p>
<p>那么，如何判断有一个数是重复的？</p>
<p>遍历整个数组，统计某个区间内出现的数的个数<code>cnt</code>     &gt;   区间大小<code>r - l + 1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line"> <span class="keyword">if</span>(x &gt;= l &amp;&amp; x &lt;= mid) cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; mid - l + <span class="number">1</span>) r = mid;  <span class="comment">//在左边重复 </span></span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;        <span class="comment">//在右重复</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">duplicateInArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//对[1,n]的数据范围进行划分，数组中的数的大小在[1,mid]之间的划分一组，属于[mid+1,r]之间的划为一组</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= l &amp;&amp; x &lt;= mid) cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(nlog_2n)$$ 每次会将区间长度缩小一半，一共会缩小$$O(log_2n)$$ 次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是$$O(n)$$。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-04-二维数组中的查找★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a>★</h3>
<blockquote>
<ul>
<li>二分法 时间O(nlogn)</li>
</ul>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png" style="zoom:33%;">
<ul>
<li>
<p>线性扫描  时间O(n+m)</p>
<p>选择右上角为起始点，若大于target,则直接左移一列；若小于target，则直接下移一行</p>
<p>时间复杂度直接变为线性O(n+m)    空间复杂度o(1)</p>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchArray</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; array, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!array.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> row = array.<span class="built_in">size</span>() - <span class="number">1</span>, col = array[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//行 列</span></span><br><span class="line">        <span class="comment">//选取右上角</span></span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>, n = col;</span><br><span class="line">        <span class="comment">// 向下向左走的过程中不能出界</span></span><br><span class="line">        <span class="keyword">while</span>(m &lt;= row &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[m][n] &gt; target) n--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[m][n] &lt; target) m++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[m][n] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(m + n)$$ 每一步会排除一行或者一列，矩阵一共有 $$m$$ 行，$$n$$列，所以最多会进行$$m+n$$步。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-05-替换空格"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h3>
<blockquote>
<p><strong>解法1</strong></p>
<p>这个题在C++里比较好做，我们可以从前往后枚举原字符串：</p>
<ul>
<li>如果遇到空格，则在string类型的答案中添加 “%20”；</li>
<li>如果遇到其他字符，则直接将它添加在答案中；</li>
</ul>
<p><strong>解法2</strong></p>
<p>原地扩容 + 双指针扫描</p>
<p>在部分编程语言中，我们可以动态地将原数组长度扩大，此时我们就可以使用双指针算法，来降低空间的使用：</p>
<ol>
<li>首先遍历一遍原数组，求出最终答案的长度length；</li>
<li>将原数组resize成length大小；</li>
<li>使用两个指针，指针i指向原字符串的末尾，指针j指向length的位置；</li>
<li>两个指针分别从后往前遍历，如果str[i] == ’ ‘，则指针j的位置上依次填充’0’, ‘2’, ‘%’，这样倒着看就是&quot;%20&quot;；如果str[i] != ’ '，则指针j的位置上填充该字符即可。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : str)</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(n)$$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpaces</span><span class="params">(string &amp;str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">&#x27; &#x27;</span>) len += <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//原地扩容</span></span><br><span class="line">        str.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="type">int</span> j = str.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">for</span>(i, j; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                str[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                str[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[j--] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-06-从尾到头打印链表★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a>★</h3>
<blockquote>
<p>遍历顺序与输出顺序相反，先进后出，自然想到用栈，或者自己用vector模拟一下也行</p>
<p>或者递归实现</p>
<ul>
<li>
<p>栈    时间O(n)  空间O(n)</p>
</li>
<li>
<p>反转链表</p>
<ul>
<li>递归  时间O(n)  空间O(n)</li>
<li>原地   时间O(n)  空间O(1)   而且题目要求打印是只读操作，所以一般不修改链表原始结构</li>
</ul>
</li>
<li>
<p>数组模拟栈，逆序输出   O(n)  空间O(1)  推荐</p>
</li>
<li>
<p>遍历链表               —推荐<br>
单链表只能从前往后遍历，不能从后往前遍历。</p>
<p>因此我们先从前往后遍历一遍输入的链表，将结果记录在答案数组中。<br>
<strong>最后再将得到的数组逆序即可。</strong></p>
</li>
</ul>
</blockquote>
<p>辅助栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val); <span class="comment">// 存的是 val</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            res[i] = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>   一个自定义的栈</li>
</ul>
<p>递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.递推阶段： 每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。</span></span><br><span class="line"><span class="comment">//2.回溯阶段： 层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。</span></span><br><span class="line"><span class="comment">//3.最终，将列表 tmp 转化为数组 res ，并返回即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(head-&gt;next);</span><br><span class="line">        res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>   递归系统栈没算在内</li>
</ul>
<p>数组模拟栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">reversePrint</span>(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null) <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计链表节点个数，方便创建数组</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后面还需要在遍历，所以不能直接用head来遍历</span></span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=null)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            tmp=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//res模拟栈，从后面装入</span></span><br><span class="line">        <span class="type">int</span>[] res=<span class="keyword">new</span> <span class="type">int</span>[count];</span><br><span class="line">        <span class="type">int</span> k = count<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后一遍遍历，后面不用head了，直接head指针遍历</span></span><br><span class="line">        <span class="keyword">while</span>(head != null)&#123;</span><br><span class="line">            res[k--] = head.val;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反转链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = cur-&gt;next;</span><br><span class="line">            </span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 无额外空间</li>
</ul>
<p>遍历链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListReversingly</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>  链表和答案数组仅被遍历了常数次，</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 无额外空间</li>
</ul>
<h3 id="剑指-Offer-07-重建二叉树★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a>★</h3>
<blockquote>
<ol>
<li>
<p>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。</p>
</li>
<li>
<p>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 <code>[ 左子树 | 根节点 | 右子树 ]</code> 。</p>
</li>
<li>
<p>根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 <code>[ 根节点 | 左子树 | 右子树 ] </code>。</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220726135625514.png" alt="image-20220726135625514" style="zoom: 50%;">
</li>
</ol>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220726135521386.png" alt="image-20220726135521386" style="zoom: 50%;">
<ul>
<li>获取根节点的值</li>
<li>获取左子树长度  ----在中序中利用hash映射求出根节点的索引</li>
<li>构造根节点</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;  </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍历中序遍历数组的映射（就是为了快速求出中序中某个元素的下标）数据为键，下标为值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            pos[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, <span class="number">0</span>, n - <span class="number">1</span>, inorder, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">int</span> l1, <span class="type">int</span> r1, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> l2, <span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; r1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> val = preorder[l1];        <span class="comment">//在先序数组获取根节点的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> index = pos[val];          <span class="comment">//获取根节点在中序遍历中的索引</span></span><br><span class="line">        <span class="type">int</span> len = index - l2;          <span class="comment">//左子树长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[l1]); <span class="comment">//构造根节点</span></span><br><span class="line">        </span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, l1 + <span class="number">1</span>, l1 + len, inorder, l2, index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, l1 + len + <span class="number">1</span>, r1, inorder, index + <span class="number">1</span>, r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>   我们在初始化时，用哈希表<code>unordered_map&lt;int,int&gt;</code>记录每个值在中序遍历中的位置，这样我们在递归到每个节点时，在中序遍历中查找根节点位置的操作，只需要 $$O(1)$$ 的时间。此时，创建每个节点需要的时间是  $$O(1)$$ ，所以总时间复杂度是 $$O(n)$$ 。</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>   构造了中序遍历数组的hash映射</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/31/">二叉树的下一个节点</a></p>
<blockquote>
<p>中序遍历二叉树的下一个节点</p>
<ul>
<li>有右孩子</li>
<li>无有孩子</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;left) p = p-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p)&#123;</span><br><span class="line">            p = p-&gt;father;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(h)$$   不论往上找还是往下找，总共遍历的节点数都不大于树的高度。所以时间复杂度是 $$O(h)$$，其中 h 是树的高度。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-09-用两个栈实现队列★"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/36/">剑指 Offer 09. 用两个栈实现队列</a>★</h3>
<blockquote>
<p>stack1：用作输入栈</p>
<p>stack2：用作输出栈</p>
<ul>
<li>
<p>当输入数据时，仅能加入stack1中</p>
</li>
<li>
<p>当输出数据时，仅能从stack2中弹出数据</p>
</li>
<li>
<p>当stack2中的数据为空时，将stack1中的数据加入stack2中即可</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stOut为空)</span><br><span class="line">  <span class="keyword">if</span>(stIn为空)  <span class="keyword">return</span> </span><br><span class="line">  stIn不为空,全部弹入stOut</span><br><span class="line">stOut弹出</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//队头元素弹出</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stOut.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stIn.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">                    stIn.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = stOut.<span class="built_in">top</span>();</span><br><span class="line">        stOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出队头元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stOut.<span class="built_in">empty</span>()) <span class="keyword">return</span> stOut.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">          stIn.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stOut.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断队列空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stOut.<span class="built_in">empty</span>() &amp;&amp; stIn.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-10-I-斐波那契数列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h3>
<blockquote>
<p>普通递归   时间O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>)</p>
<p>记忆化递归法（自上向下）    时间O(n)  空间O(n)</p>
<p>自底向上   时间O(n)  空间O(1)</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220726191223571.png" alt="image-20220726191223571" style="zoom:67%;">
</blockquote>
<p>普通递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(2^n)$$   递归计算的节点个数是 O(2n)O(2n) 的级别的，存在大量重复计算。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<p>记忆化递归法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            arr[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(n);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//相比普通递归，加了arr[n]的判断和每次将计算结果sum记录在arr[n]</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[n] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">        arr[n] = sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自底向上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="type">int</span> c = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img108249e4d62d429f9cd6cab5bbd6afca581ee61c7d762a4c8ea0c62e08e10762-Picture13.png" alt="Picture13.png" style="zoom:67%;">
<p>如何达到第n个台阶？</p>
<p>第n-2个台阶跳两步    第n-1个台阶跳一步</p>
<p>f(n)=f(n-1)+f(n-2)</p>
</blockquote>
<h3 id="剑指-Offer-11-旋转数组的最小数字★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a>★</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l] &lt; numbers[r]) <span class="keyword">return</span> numbers[l];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[l]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[r]) r = mid;   <span class="comment">//在右边，不能-1，因为旋转点就在右排序数组</span></span><br><span class="line">            <span class="keyword">else</span> l = l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>易懂版</strong></p>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img1_9f7a5ff011-2.png" alt="2.png" style="zoom:50%;">
<ul>
<li>把数组第一个值nums[0]当作target，</li>
<li>当数组不重复时，是可以当作纯二分法的，<strong>大于等于</strong>的在左边，比target小的在右边</li>
<li>当数组重复时，无法直接二分，比如<code>nums[0] == nums[n-1]</code>，等于target时，既有可能在左边，也有可能在右边。</li>
<li>所以，我们只需要消除右区间和nums[0]重复的数字即可，这样就可以再用二分法了</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> target = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//消除右区间的右端点与target重复的值</span></span><br><span class="line">        <span class="keyword">while</span>(r &gt; <span class="number">0</span> &amp;&amp; nums[r] == target) r--;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] &gt;= target) <span class="keyword">return</span> target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) r = mid;  <span class="comment">//经过前面的处理，小于target一定在右边</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;              <span class="comment">//大于等于target一定在左边   </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$   二分的时间复杂度是 $$O(log_2n)$$，删除最后水平一段的时间复杂度最坏是$$O(n)$$，所以总时间复杂度是 $$O(n)$$。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-12-矩阵中的路径★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a>★</h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img1604944042-glmqJO-Picture0.png" alt="Picture0.png" style="zoom: 33%;">
<h5 id="DFS-解析：">DFS 解析：</h5>
<ul>
<li>
<p><strong>递归参数：</strong> 当前元素在矩阵 <code>board</code> 中的行列索引 <code>i</code> 和 <code>j</code> ，当前目标字符在 <code>word</code> 中的索引 <code>k</code> 。</p>
</li>
<li>
<p>终止条件：</p>
<ol>
<li>返回 false ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ）</li>
<li>返回 true ：<code>k = len(word) - 1</code>，即字符串 word 已全部匹配。</li>
</ol>
</li>
</ul>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img1055_5ca7e38e50-2.png" alt="2.png" style="zoom:50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, string &amp;str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, str, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, string &amp;str,<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界或者值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>() || matrix[i][j] != str[u])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//已经访问过的，直接赋值一个不可能出现的字符，直接利用判断值相等的条件去pass，不用单独设置一个访问数组</span></span><br><span class="line">        matrix[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(matrix, str, i - <span class="number">1</span>, j, u + <span class="number">1</span>) || <span class="built_in">dfs</span>(matrix, str, i + <span class="number">1</span>, j, u + <span class="number">1</span>) ||</span><br><span class="line">                    <span class="built_in">dfs</span>(matrix, str, i, j - <span class="number">1</span>, u + <span class="number">1</span>) || <span class="built_in">dfs</span>(matrix, str, i, j + <span class="number">1</span>, u + <span class="number">1</span>);</span><br><span class="line">                    </span><br><span class="line">        matrix[i][j] = str[u];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, string &amp;str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, str, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//矩阵非引用类型，自动恢复现场</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; matrix, string &amp;str,<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>() || matrix[i][j] != str[u])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        matrix[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="comment">//四个方向暴搜</span></span><br><span class="line">        <span class="type">bool</span> res = <span class="built_in">dfs</span>(matrix, str, i - <span class="number">1</span>, j, u + <span class="number">1</span>) || <span class="built_in">dfs</span>(matrix, str, i + <span class="number">1</span>, j, u + <span class="number">1</span>) ||</span><br><span class="line">                    <span class="built_in">dfs</span>(matrix, str, i, j - <span class="number">1</span>, u + <span class="number">1</span>) || <span class="built_in">dfs</span>(matrix, str, i, j + <span class="number">1</span>, u + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方向偏移量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix, string &amp;str)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, str, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; matrix, string &amp;str,<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].<span class="built_in">size</span>() || matrix[i][j] != str[u])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        matrix[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(matrix, str, i + dx[k], j + dy[k], u + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n^23^k)$$   单词起点一共有 $$n^2$$ 个，单词的每个字母一共有上下左右四个方向可以选择，但由于不能走回头路，所以除了单词首字母外，仅有三种选择。所以总时间复杂度是 $$O(n^23^k)$$， k为单词个数。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-13-机器人的运动范围"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h3>
<blockquote>
<p>题目描述</p>
<p>地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。</p>
<p>一个机器人从坐标 (0,0)的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。</p>
<p>但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>请问该机器人能够达到多少个格子？</p>
</blockquote>
<p><strong>深度优先搜索</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">dfs</span>(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//符合条件，可以从该点向四周延伸</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i,j,threshold))&#123;</span><br><span class="line">            res++;</span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(threshold, rows, cols, i - <span class="number">1</span>, j, visited);</span><br><span class="line">            <span class="built_in">dfs</span>(threshold, rows, cols, i + <span class="number">1</span>, j, visited);</span><br><span class="line">            <span class="built_in">dfs</span>(threshold, rows, cols, i, j - <span class="number">1</span>, visited);</span><br><span class="line">            <span class="built_in">dfs</span>(threshold, rows, cols, i, j + <span class="number">1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断横纵坐标之和是否符合条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parse</span>(i) + <span class="built_in">parse</span>(j) &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析一个数的所有位数相加</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parse</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//简化函数的参数，全局变量全部提取出来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rows, cols, threshold;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> rows, <span class="type">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;rows = rows;   <span class="comment">//类似java的this.rows = rows;将题目给的函数参数同步到全局变量</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;cols = cols;</span><br><span class="line">        <span class="keyword">this</span>-&gt;threshold = threshold;</span><br><span class="line">        visited = &#123;rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols, <span class="number">0</span>)&#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//越界</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(visited[i][j]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//符合条件，可以从该点向四周延伸</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i,j,threshold))&#123;</span><br><span class="line">            res++;</span><br><span class="line">            visited[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i - <span class="number">1</span>, j);</span><br><span class="line">            <span class="built_in">dfs</span>(i + <span class="number">1</span>, j);</span><br><span class="line">            <span class="built_in">dfs</span>(i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断横纵坐标之和是否符合条件</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> threshold)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parse</span>(i) + <span class="built_in">parse</span>(j) &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析一个数的所有位数相加</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parse</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剪绳子"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/24/">剪绳子</a></h3>
<ul>
<li>给定一个大于 11 的正整数 n，要求将 <em>n</em> 拆分成至少两个正整数的和，并使这些正整数的乘积最大化，返回最大乘积。</li>
</ul>
<blockquote>
<p>dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积</p>
<p>那么初始化dp[1] = 1;</p>
<p>我们需要求到dp[n]，正整数n的拆分最大化</p>
<p>状态转移方程</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20221110103751723.png" alt="image-20221110103751723"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = length;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;   </span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                m = <span class="built_in">max</span>(m, <span class="built_in">max</span>(j *(i - j), dp[j] * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n^2)$$</li>
<li>空间复杂度：$$O(n)$$</li>
</ul>
<h3 id="剑指-Offer-15-二进制中1的个数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h3>
<p>输入一个 32 位整数，输出该数二进制表示中 1 的个数。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>负数在计算机中用其绝对值的补码来表示。</li>
</ul>
<blockquote>
<p><strong>位运算</strong>—逐位判断<br>
迭代进行如下两步，直到 n 变成0为止：</p>
<ul>
<li>如果 n 在二进制表示下末尾是1，则在答案中加1；</li>
<li>将 n 右移一位，也就是将 n 在二进制表示下的最后一位删掉；</li>
</ul>
<p>这里有个难点是如何处理负数。<br>
在C++中如果我们右移一个负整数，系统会自动在最高位补1，这样会导致 n 永远不为0，就死循环了。<br>
解决办法是把 n 强制转化成无符号整型，这样 n 的二进制表示不会发生改变，但在右移时系统会自动在最高位补0。</p>
<p><strong>巧用 n &amp; (n - 1)</strong></p>
<p><strong>(n - 1) 解析</strong>： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。<br>
<strong>n &amp; (n - 1) 解析</strong>： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20221110110918626-16680497602791.png" alt="image-20221110110918626" style="zoom:33%;">
<p><strong>算法流程：</strong></p>
<ol>
<li>
<p>初始化数量统计变量 res 。</p>
</li>
<li>
<p>循环消去最右边的 1 ：当 n = 0 时跳出。<br>
res += 1 ： 统计变量加 1 ；<br>
n &amp;= n - 1 ： 消去数字 n 最右边的 1 。</p>
</li>
<li>
<p>返回统计数量 res。</p>
</li>
</ol>
<p>结论：把一个整数-1，再和原整数做与运算，会把该整数最右边的1变成0</p>
</blockquote>
<p><strong>常规解法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> _n)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> n = _n; <span class="comment">//变为无符号整数，防止右移时高危补1出现死循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            sum += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;      <span class="comment">//右移并赋值  &gt;&gt;=</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(log_2n)$$   每次会将 n除以2，最多会除 logn次，所以时间复杂度是 O(logn)。</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<p><strong>n &amp; (n - 1)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);  </span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(M)$$   M大小等于二进制表示中1的个数</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-16-数值的整数次方"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h3>
<blockquote>
<p><strong>快速幂</strong></p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20221110135907306.png" alt="image-20221110135907306"></p>
<p>任何一个正整数，一定可以拆成1，2，4，8，16这种组合相加形式</p>
<p>即任何一个二进制可以拆成0001,0010,0100,1000,10000,这种二进制相加形式</p>
<p><strong>转换成幂，就是他们的相乘形式</strong></p>
<p>我们先看代码，再来仔细推敲这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(n)&#123;</span><br><span class="line">     <span class="keyword">if</span>(n &amp; <span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">         ans *= a;    <span class="comment">//ans乘上当前的a</span></span><br><span class="line">     a *= a;          <span class="comment">//a自乘</span></span><br><span class="line">     n &gt;&gt;= <span class="number">1</span>;         <span class="comment">//n往右移一位</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本题边界</strong></p>
<p>int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行 n = -n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> <span class="title function_">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!exponent) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> exponent;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            base = <span class="number">1</span> / base;</span><br><span class="line">            n = -n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快速幂</span></span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="在O-1-时间删除链表节点"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/85/">在O(1)时间删除链表节点</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-17-打印从1到最大的n位数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">10</span>, n);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[sum - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sum; i++)</span><br><span class="line">            res[i-<span class="number">1</span>] = i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-18-删除链表的节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h3>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220821091111378.png" alt="image-20220821091111378"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;  <span class="comment">//设置虚拟头结点，避免单独判断是否删除第一个节点,统一返回dummy.next</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                <span class="keyword">return</span> dummy.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next; <span class="comment">//单独判断删除的第一个节点，直接返回第二个节点head.next</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur != <span class="literal">null</span>) pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表重复节点-★"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/27/">删除链表重复节点</a> ★</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> tmp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="comment">//此内循环过后，cur-&gt;next 一定将之前重复出现的数组跳过了</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == tmp)&#123;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-19-正则表达式匹配"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h3>
<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> i = <span class="number">0</span>, j = array.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">             <span class="comment">//左指针向右遍历，找到第一个偶数</span></span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; array[i] % <span class="number">2</span>) i++;</span><br><span class="line">             <span class="comment">//右指针向左遍历，找到第一个奇数</span></span><br><span class="line">             <span class="keyword">while</span>(i &lt; j &amp;&amp; array[j] % <span class="number">2</span> == <span class="number">0</span>) j--;</span><br><span class="line">             <span class="built_in">swap</span>(array[i], array[j]);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-22-链表中倒数第k个节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h3>
<blockquote>
<p>引用删除倒数第k个节点的思路，双指针</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220821103911539.png" alt="image-20220821103911539"></p>
<ul>
<li>单链表：只有后继指针，对于单链表，想要删除某个节点A，我们一定要找到A的<code>前一个指针B</code>，让B-&gt;next=A-&gt;next,实现删除。</li>
<li>所以本题删除倒数第n个节点，实际上是找到倒数n+1个节点，</li>
<li>本题是有可能删除头节点的，凡事有可能删除头节点的题目，都会有一个常用的技巧：<strong>创建一个虚拟节点，让虚拟节点指向头节点，虚拟节点是一定不会删除的，这样就不用额外处理头节点被删除的情况</strong></li>
<li><code>思路</code>
<ol>
<li>建立虚拟头结点</li>
<li>first指针，从前向后走n步</li>
<li>last指针，从头开始和已经走了n步的first指针一起走。两者始终相差n步，那么当first走到终点，last指针是倒数第n个节点。</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = pListHead;</span><br><span class="line">        <span class="keyword">auto</span> p = dummy, q = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//理论上最多走到最后一个实节点</span></span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后p一定指向null,q与p相差k个节点</span></span><br><span class="line">        <span class="comment">//如果是删除倒数第k个节点，就让p指向最后一个实节点  while(p-&gt;next)</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-II-022-链表中环的入口节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></h3>
<p>题目主要信息:</p>
<ul>
<li>给定一个链表，首先判断其是否有环，然后找到环的入口</li>
</ul>
<blockquote>
<p><strong>快慢指针，结论题</strong></p>
<p>根据题干，不说别的，我们能发现这道题需要完成两个任务：</p>
<ol>
<li>判断链表是否有环。</li>
<li>在有环的链表中找到环的入口。</li>
</ol>
<ul>
<li>step 1：使用<strong>判断链表中是否有环</strong>中的方法判断链表是否有环，并找到相遇的节点。</li>
<li>step 2：==慢指针继续在相遇节点，快指针回到链表头，两个指针同步逐个元素逐个元素开始遍历链表。==</li>
<li>step 3：再次相遇的地方就是环的入口。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = <span class="built_in">has_cycle</span>(head);</span><br><span class="line">        <span class="keyword">if</span>(!slow) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;          <span class="comment">//环中相遇时，将fast回到原点，slow继续在相遇点</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否有环</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">has_cycle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-24-反转链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220821112414155.png" alt="image-20220821112414155" style="zoom:50%;">
<p>反转链表需要当前节点的前一个节点pre，用于反转指向</p>
<p>为防止反转后，链表断开找不到后面的节点，需要不停的记录当前节点cur的下一个节点next作为临时节点</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = cur-&gt;next;  <span class="comment">//防止断链，记录当前节点的下一个节点tmp</span></span><br><span class="line">            </span><br><span class="line">            cur-&gt;next = pre;  <span class="comment">//反转</span></span><br><span class="line">            <span class="comment">// 移动节点，用于后面节点的反转</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur= tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归做法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> node = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<blockquote>
<p>递归理解：</p>
<p>基本上，<strong>所有的递归问题都可以用递推公式来表示。有了这个递推公式，我们就可以很轻松地将它改为递归代码。</strong>。所以，遇到递归不要怕，先想<strong>递推公式</strong>。</p>
<h5 id="例1-比较明显的能递推公式的问题">例1: (比较明显的能递推公式的问题)</h5>
<ul>
<li>问题：斐波那契数列的第n项</li>
<li>递推公式：</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(n)</span>=<span class="title">f</span><span class="params">(n-<span class="number">1</span>)</span>+<span class="title">f</span><span class="params">(n-<span class="number">2</span>)</span> 其中，<span class="title">f</span><span class="params">(<span class="number">0</span>)</span>=0,<span class="title">f</span><span class="params">(<span class="number">1</span>)</span>=1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>终止条件：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(n<span class="number">-1</span>) + <span class="built_in">f</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例2:(不那么明显的有递推公式的问题)</strong></p>
<ul>
<li>问题：逆序打印一个数组</li>
<li>递推公式：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设令<span class="constructor">F(<span class="params">n</span>)</span>=逆序遍历长度为n的数组</span><br><span class="line">那么<span class="constructor">F(<span class="params">n</span>)</span>= 打印数组中下标为n的元素 + <span class="constructor">F(<span class="params">n</span>-1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>终止条件：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归代码：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="constructor">Print(<span class="params">int</span>[] <span class="params">nums</span>,<span class="params">int</span> <span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) return;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(nums<span class="literal">[<span class="identifier">n</span>]</span>);</span><br><span class="line">    <span class="constructor">Print(<span class="params">nums</span>,<span class="params">n</span>-1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，不知道大家对写递归有没有一些理解了。其实写递归不能总想着去把递归平铺展开，这样脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。只要找到<strong>递推公式</strong>，我们就能很轻松地写出递归代码。</p>
<p>到这里，我想进一步跟大家说明我这个思路是比较能够容易出代码的，那么就树的遍历问题来和大家讲。递归总是和树分不开，其中，最典型的便是树的遍历问题。刚开始学的时候，不知道大家是怎么理解先／中／后序遍历的递归写法的，这里我提供我的思路供参考，以前序遍历为例：</p>
<ul>
<li>
<p>问题：二叉树的先序遍历</p>
</li>
<li>
<p>递推公式：</p>
</li>
<li>
<pre><code class="language-reasonml">令F(Root)为问题:遍历以Root为根节点的二叉树，
令F(Root.left)为问题:遍历以F(Root.left)为根节点的二叉树
令F(Root.right)为问题:遍历以F(Root.right)为根节点的二叉树
那么其递推公式为：
F(Root)=遍历Root节点+F(Root.left)+F(Root.right)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 递归代码：</span><br><span class="line"></span><br><span class="line">```reasonml</span><br><span class="line">public void preOrder(TreeNode node)&#123;</span><br><span class="line">    if(node==null) return;</span><br><span class="line">    System.out.println(node.val);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.righr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p><strong>Rules Number Two</strong>, <strong>递归是一种关于某个重复动作(完成重复性的功能)的形式化描述</strong>。具体点讲，如果一个问题 A 可以分解为若干子问题 B、C、D，<strong>你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A</strong>。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系(也就是说，递归只能考虑当前层和下一层的关系，不能继续往下深入)。我们需要屏蔽掉递归细节，理解为完成了某种功能的形式化描述即可。</p>
<p>好了，那我们来分析这个题。</p>
<ul>
<li>问题：单向链表的反转</li>
<li>递推公式：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">令<span class="constructor">F(<span class="params">node</span>)</span>为问题:反转以node为头节点的单向链表；</span><br><span class="line">一般，我们需要考虑<span class="constructor">F(<span class="params">n</span>)</span>和<span class="constructor">F(<span class="params">n</span>-1)</span>的关系，那么这里，如果n代表以node为头节点的单向链表，那么n-<span class="number">1</span>就代表以node.next为头节点的单向链表.</span><br><span class="line">所以，我们令<span class="constructor">F(<span class="params">node</span>.<span class="params">next</span>)</span>为问题：反转以node.next为头节点的单向链表；</span><br><span class="line">那么，<span class="constructor">F(<span class="params">node</span>)</span>和<span class="constructor">F(<span class="params">node</span>.<span class="params">next</span>)</span>之间的关系是？这里我们来简单画个图，假设我们反转<span class="number">3</span>个节点的链表：</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line">那么，<span class="constructor">F(<span class="params">node</span>=1)</span>=<span class="constructor">F(<span class="params">node</span>=2)</span>+?</span><br><span class="line">这里假设子问题<span class="constructor">F(<span class="params">node</span>=2)</span>已经解决，那么我们如何解决<span class="constructor">F(<span class="params">node</span>=1)</span>：</span><br><span class="line">很明显，我们需要反转node=<span class="number">2</span>和node=<span class="number">1</span>， 即 node.next.next=node; 同时 node.next=null;</span><br><span class="line">所以，这个问题就可以是：<span class="constructor">F(<span class="params">node</span>=1)</span>=<span class="constructor">F(<span class="params">node</span>=2)</span>+ 反转node=<span class="number">2</span>和node=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>递归代码：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title class_">ListNode</span> reverseList(<span class="title class_">ListNode</span> head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null |<span class="params"></span>| head.<span class="keyword">next</span> == null) &#123;  <span class="regexp">//</span>终止条件并不难想</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">ListNode</span> node = reverseList(head.<span class="keyword">next</span>);</span><br><span class="line">        head.<span class="keyword">next</span>.<span class="keyword">next</span> = head;</span><br><span class="line">        head.<span class="keyword">next</span> = null;</span><br><span class="line">        <span class="keyword">return</span> node;  <span class="regexp">//</span>按上面的例子，F(node=<span class="number">1</span>)和F(node=<span class="number">2</span>)它俩反转后的头节点是同一个</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>3.写递归的小tips<br>
（发现写递归的过程中有些小体会，虽然时隔很久但还是过来更新啦！)</p>
<ul>
<li>
<p>将问题抽象化，可以将问题抽象为f(n)（或者其他的数学符号）, 然后用f(n)代表欲求的问题，然后去发现和子问题（比如f(n-1)）的递推关系！（这一点在写动态规划的时候特别有用，其实动态规划就是记忆化的递归！）</p>
</li>
<li>
<p>递归函数是带语义的，但是记住一个递归函数只有一个语义，如果在写递归函数实现的时候，发现出现了多个语义，需要对新出现的语义重新定义一个函数！</p>
</li>
<li>
<p>在写递归函数的时候，可以先写子问题<code>f(n-1)</code>，再写所求问题<code>f(n)</code>，这样的话就很好知道<code>f(n)</code>和<code>f(n-1)</code>的关系，更容易保证一个递归函数只包含一个语义。</p>
</li>
</ul>
<p>注意事项：</p>
<p>确定好递归函数的语义/功能；</p>
<p>确定递归表达式</p>
<p>确定边界判断条件（几个条件的判断顺序也很重要）</p>
<p>确定好是否需要另外取一个递归函数，还是直接用题目提供的函数</p>
</blockquote>
<h3 id="剑指-Offer-25-合并两个排序的链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h3>
<blockquote>
<p>二路归并</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-26-树的子结构"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h3>
<blockquote>
<ol>
<li>先序遍历A中的每一个节点（对应函数 <code>isSubStructure(A, B)</code>）</li>
<li>判断树 A<em>A</em> 中 <strong>以 n_A为根节点的子树</strong> 是否包含树 B 。（对应函数 <code>recur(A, B)</code>）</li>
</ol>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img27d9f65b79ae4982fb58835d468c2a23ec2ac399ba5f38138f49538537264d03-Picture1.png" alt="Picture1.png" style="zoom: 33%;">
<p><strong><code>recur(A, B)</code> 函数：</strong></p>
<ol>
<li>
<p><strong>终止条件：</strong></p>
<p>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true；<br>
当节点 A 为空且B不为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；</p>
<p>当节点 A和 B 的值不同：说明匹配失败，返回 false ；</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">compare</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !subRoot) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> a = <span class="built_in">compare</span>(root, subRoot);</span><br><span class="line">        <span class="type">bool</span> b = <span class="built_in">isSubtree</span>(root-&gt;left, subRoot);</span><br><span class="line">        <span class="type">bool</span> c = <span class="built_in">isSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a || b || c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子树指的是主树的一部分即可，即使主树下面还有节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root || !subRoot) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> a = <span class="built_in">compare</span>(root, subRoot);</span><br><span class="line">        <span class="type">bool</span> b = <span class="built_in">hasSubtree</span>(root-&gt;left, subRoot);</span><br><span class="line">        <span class="type">bool</span> c = <span class="built_in">hasSubtree</span>(root-&gt;right, subRoot);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a || b || c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//子树的节点被比较完了（还没发现错）返回true</span></span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">compare</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(m*n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-27-二叉树的镜像"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> NULL;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">        mirrorTree(root-&gt;left);</span><br><span class="line">        mirrorTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-28-对称的二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool <span class="title function_">isSymmetric</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool <span class="title function_">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-29-顺时针打印矩阵"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220821181957955.png" alt="image-20220821181957955" style="zoom:50%;">
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220821182019747.png" alt="image-20220821182019747"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!matrix.<span class="built_in">size</span>() || !matrix[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), cols = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cols - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>, b = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum = rows * cols;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) res.<span class="built_in">push_back</span>(matrix[t][i]);</span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = t; i &lt;= b; i++) res.<span class="built_in">push_back</span>(matrix[i][r]);</span><br><span class="line">            <span class="keyword">if</span>(--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = r; i &gt;= l; i--) res.<span class="built_in">push_back</span>(matrix[b][i]);</span><br><span class="line">            <span class="keyword">if</span>(--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = b; i &gt;= t; i--) res.<span class="built_in">push_back</span>(matrix[i][l]);</span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>偏移量用法：</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20230605092006570.png" alt="image-20230605092006570"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!matrix.<span class="built_in">size</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span> , <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//d = 0,1,2,3  都是指一个方向</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            matrix[x][y] = <span class="number">1000000</span>;  <span class="comment">//设置visit[][]更合适</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> a = x + dx[d], b = y + dy[d];   <span class="comment">//直走</span></span><br><span class="line">            <span class="comment">//判断是否撞墙、重复</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= m || b &lt; <span class="number">0</span> || b &gt;= n || matrix[a][b] == <span class="number">1000000</span>)&#123;</span><br><span class="line">                <span class="comment">//逆时针换个方向走</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$     n为矩阵元素个数</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-30-包含min函数的栈"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20221031095611018.png" alt="image-20221031095611018" style="zoom:50%;">
<p>push、pop、top这些功能一个基本的栈就可以完成了，那么还有一个获取当前栈的最小元素的功能，需要一个辅助栈来完成（单调栈）----用来实时保存当前栈中的最小元素（存放在栈顶）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st, min_st;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基本栈肯定直接push，单调栈是否入栈呢？---单调栈为null、要加入的数据 &lt;= 单调栈中的栈顶元素，直接加入，保持最小元素的更新</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        st.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_st.empty() || min_st.top() &gt;= x)&#123;  <span class="comment">//辅助栈为空也是要入栈的，比如第一个元素</span></span><br><span class="line">            min_st.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基本栈肯定直接弹出，那么单调栈是否需要弹出？----判断要弹出的元素是否等于单调栈的栈顶元素，等于，则也弹出</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(min_st.top() == st.top()) min_st.pop();  </span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> st.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单调栈中的栈顶元素就是当前最小元素</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min_st.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-31-栈的压入、弹出序列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h3>
<blockquote>
<p>入栈顺序和出栈顺序确定，则pop(),push()的操作顺序也是唯一确定的</p>
<ul>
<li><strong>入栈操作：</strong> 按照压栈序列的顺序执行。</li>
<li><strong>出栈操作：</strong> 每次入栈后，循环判断 <code>“栈顶元素 == 弹出序列的当前元素” </code>是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</li>
</ul>
<p>算法流程：</p>
<ol>
<li>
<p><strong>初始化：</strong> 辅助栈 stack ，弹出序列的索引 i；</p>
</li>
<li>
<p><strong>遍历压栈序列</strong>： 各元素记为 num；for(int num: pushed)</p>
<ol>
<li>元素 num 入栈 stack；</li>
<li><strong>循环出栈</strong>：若 stack 的栈顶元素 == 弹出序列元素 popped[i] ，则执行出栈与 i++ ；while(…)</li>
</ol>
</li>
<li>
<p><strong>返回值：</strong> 若 stack 为空，则此弹出序列合法。</p>
</li>
</ol>
<p>最好是对着测试用例，手动模拟一下</p>
<p>创建一个栈，模拟整个入栈，出栈过程</p>
<p>队列1是入栈顺序，队列2是出栈顺序</p>
<p>只会有两种操作：</p>
<p>操作1：将下一个数加入栈中</p>
<p>操作2：将当前栈顶元素弹出</p>
<p>判断当前栈顶元素是否和下一个要输出的数【队列2】一样</p>
<p>情况1:一样，操作2</p>
<p>情况2：不一样，操作1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV,vector&lt;<span class="type">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.<span class="built_in">size</span>() != popV.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历入队元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pushV)&#123;</span><br><span class="line">            <span class="comment">//先入队</span></span><br><span class="line">            st.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="comment">//再看是否要弹出</span></span><br><span class="line">            <span class="comment">//注意st.size() &amp;&amp; st.top() == popV[i]，先判断是否为空，短路效应</span></span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; st.<span class="built_in">top</span>() == popV[i])&#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) q.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) q.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        q.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.remove();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3>
<blockquote>
<p><strong>c++中bool类型取反符号是 !</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">printFromTopToBottom</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="type">bool</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="type">auto</span> <span class="variable">tmp</span> <span class="operator">=</span> q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                level.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right) q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;  <span class="comment">//注意取反符号是！，不是-、~</span></span><br><span class="line">            <span class="keyword">if</span>(flag) reverse(level.begin(), level.end());</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$     树中每个节点仅会进队出队一次，所以时间复杂度是 O(n)</li>
<li>空间复杂度：$$O(n)$$</li>
</ul>
<h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimgimage-20220822131113526.png" alt="image-20220822131113526" style="zoom:50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verifySequenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        seq = sequence;             <span class="comment">//将seq提升为全部变量，两个函数都能用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>, sequence.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归表达式：dfs(i,j) = dfs(i,p-1) &amp;&amp; dfs(p,j-1) + &#123;[j]&gt;[i,p-1] &amp; [j]&lt;[p,j-1]&#125;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> root = seq[r];</span><br><span class="line">        <span class="type">int</span> i = l;</span><br><span class="line">        <span class="comment">//获取第一个大于等于root的元素的位置，即左子树</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r &amp;&amp; root &gt; seq[i]) i++;</span><br><span class="line">        <span class="comment">//检查右子树元素大小是否全部合法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; r; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[j] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(l, i - <span class="number">1</span>) &amp;&amp; <span class="built_in">dfs</span>(i, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n^2)$$      n为二叉树节点的个数, 当树为链式时时间复杂度最坏为$$O(n^2)$$</li>
<li>空间复杂度：$$O(n)$$   设置一个全局变量</li>
</ul>
<h3 id="剑指-Offer-34-二叉树中和为某一值的路径-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a> ★</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findPath</span>(TreeNode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* cur, <span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根节点的处理</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        sum -= cur-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; !sum) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(cur-&gt;left, sum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(cur-&gt;right, sum);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(cur-&gt;left)&#123;</span></span><br><span class="line">        <span class="comment">//     dfs(cur-&gt;left, sum);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(cur-&gt;right)&#123;</span></span><br><span class="line">        <span class="comment">//     dfs(cur-&gt;right, sum);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// path.pop_back();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$      n为二叉树节点的个数</li>
<li>空间复杂度：$$O(n)$$</li>
</ul>
<h3 id="剑指-Offer-35-复杂链表的复制-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a> ★</h3>
<blockquote>
<p>此题考查链表的知识点操作的知识点较多</p>
<p>关键点在于链表的<strong>复制和拆分</strong></p>
<ul>
<li>链表的复制+拼接</li>
</ul>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/image-20230604110109610.png" alt="image-20230604110109610" style="zoom:50%;">
<ul>
<li>
<p>链表的random指针的复制</p>
</li>
<li>
<p>链表的拆解</p>
</li>
</ul>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/image-20230604140848347.png" alt="image-20230604140848347" style="zoom:50%;">
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/image-20230604141008563.png" alt="image-20230604141008563" style="zoom:50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//复制一个小弟</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p ; p = p-&gt;next-&gt;next)&#123;</span><br><span class="line">           <span class="keyword">auto</span> q = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">           q-&gt;next = p-&gt;next;</span><br><span class="line">           p-&gt;next = q;</span><br><span class="line">       &#125;</span><br><span class="line">		<span class="comment">//random节点复制</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p= p-&gt;next-&gt;next)&#123;</span><br><span class="line">           <span class="keyword">if</span>(p-&gt;random)&#123;</span><br><span class="line">               p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//奇偶序拆分</span></span><br><span class="line">       <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">       <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> p= head; p; p = p-&gt;next)&#123;</span><br><span class="line">           cur-&gt;next = p-&gt;next;</span><br><span class="line">           cur = cur-&gt;next;</span><br><span class="line">           p-&gt;next = p -&gt;next-&gt;next;  <span class="comment">//断开</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-36-二叉搜索树与双向链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h3>
<p>题目的主要信息：</p>
<ul>
<li>将二叉搜索树转化成递增序的双向链表</li>
<li>不能添加新的结点，要在原结点基础上添加链表链接</li>
<li>返回链表中的第一个节点的指针</li>
<li>二叉树节点的左右指针看成双向链表的前后指针</li>
</ul>
<blockquote>
<p>双向循环链表</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* head = <span class="literal">NULL</span>, *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cur) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!pre) head = cur;     <span class="comment">// pre为NULL, 说明一直向左深度遍历，找到最小的节点，即头结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//每一个结点访问时它的左子树肯定被访问过了，所以放心大胆的改它的left指针，不怕树断掉</span></span><br><span class="line">            cur-&gt;left = pre;</span><br><span class="line">            pre-&gt;right = cur; <span class="comment">//pre指向的结点保存的数肯定小于当前结点,所以其左右子树肯定都访问过   </span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">//开始更新pre, 将pre向后移</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-37-序列化二叉树-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a> ★</h3>
<blockquote></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            res += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val) +<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs_s</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs_s</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(queue&lt;string&gt;&amp; q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">front</span>() == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(q.<span class="built_in">front</span>()));</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs_d</span>(q);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs_d</span>(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="comment">//实现字符串split功能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] != <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span>(data[j] != <span class="string">&#x27;,&#x27;</span>) j++;</span><br><span class="line">                q.<span class="built_in">push</span>(data.<span class="built_in">substr</span>(i,j - i));</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转为队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs_d</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="数字全排列-★"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/47/">数字全排列</a> ★</h3>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img20201124201331223.png" alt="47.全排列II1" style="zoom: 50%;">
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutation</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枚举某个位置可以填写哪些数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">                <span class="comment">//当前数和前一个枚举的数相同，前一个没有使用，则说明前一个需要递归使用</span></span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(nums,used);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h3>
<p>题目主要信息:</p>
<ul>
<li>题目给出一个长度为n的数组，其中有一个数字出现次数超过了数组长度的一半，需要我们找出这个数字</li>
<li>输入数组非空，保证有解，这样就不用考虑特殊情况</li>
</ul>
<blockquote>
<ol>
<li>哈希表法  时间复杂度$$O(n)$$，空间复杂度$$O(n)$$</li>
<li>摩尔投票法-----难想出来    时间复杂度$$O(n)$$，空间复杂度$$O(1)$$
<ul>
<li>“其中有一个数字出现次数超过了数组长度的一半” &lt;===&gt; <strong>某一个数出现的次数比其他所有数出现的次数之和都多</strong></li>
</ul>
</li>
<li>排序</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, veto = <span class="number">0</span>;        <span class="comment">//x预定的“众数”， veto 众数对应的票数 只要不为0，x就是众数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!veto)  x = num;</span><br><span class="line">            <span class="keyword">if</span>(x == num) veto++;</span><br><span class="line">            <span class="keyword">else</span> veto--;        <span class="comment">//不是众数 直接消除他的票数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$</li>
<li>空间复杂度：$$O(1)$$</li>
</ul>
<h3 id="剑指-Offer-40-最小的k个数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h3>
<blockquote>
<p><strong>priority_queue</strong> ，又称<em><strong>优先队列</strong></em> ，是一个容器----允许在$$O(log_N)$$时间复杂度下<strong>插入</strong>数据，在$$O(1)$$时间复杂度下取得容器的最大（最小）值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优先队列就是大顶堆，队头元素最大。</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">         priority_queue&lt;<span class="type">int</span>&gt; heap;      <span class="comment">//优先队列，默认是大顶堆。</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)&#123;</span><br><span class="line">             heap.<span class="built_in">push</span>(x);</span><br><span class="line">             <span class="keyword">if</span>(heap.<span class="built_in">size</span>() &gt; k) heap.<span class="built_in">pop</span>();  <span class="comment">//优先弹出大的，最后剩下的k个数一定是k个最小的数</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">         <span class="keyword">while</span>(heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">             res.<span class="built_in">push_back</span>(heap.<span class="built_in">top</span>());</span><br><span class="line">             heap.<span class="built_in">pop</span>();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(nlog_2k)$$ 构建和维护大小$$K$$为的堆，需要$$log_2K$$，加上遍历整个数组</p>
</li>
<li>
<p>空间复杂度：$$O(k)$$，堆空间为$$K$$个元素</p>
</li>
</ul>
<p>快速选择</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; q, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= j)  <span class="built_in">quick_sort</span>(q, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">quick_sort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k ; i++) res.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(k)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-42-连续子数组的最大和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220824163405528-16613300474191.png" alt="image-20220824163405528" style="zoom: 50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i] 以元素 num[i] 结尾的连续子数组最大和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>] + nums[i], nums[i]);   <span class="comment">//判断dp[i]是从nums[i]单独重新计算，还是加上nums[i]一起</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(n)$$</p>
</li>
</ul>
<p>优化：一维滚动数组dp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            nums[i] = <span class="built_in">max</span>(nums[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(nums[i], res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-44-数字序列中某一位的数字-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a> ★</h3>
<blockquote>
<p>数字规律题—数位统计</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img2cd7d8a6a881b697a43f153d6c10e0e991817d78f92b9201b6ab71e44cb619de-Picture1.png" alt="Picture1.png" style="zoom:25%;">
<p>传入位序 n （从0开始）:</p>
<ol>
<li>
<p>确定n所在<strong>数字</strong>的<strong>位数</strong>(就是确定这个数字是1位数、2位数、3位数…)，记为digit</p>
</li>
<li>
<p>确定 n 所在的 <strong>数字</strong>（就是是1个数范围内，还是10十分位，还是100百分位），记为num，</p>
</li>
<li>
<p>确定 n 是 num中的哪一数位，并返回结果</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i表示几位数，从1位数开始, s表示几位数一共有几个数，比如1位数有10个，2位数有90个..</span></span><br><span class="line">        <span class="comment">//base表示几位数的基数是多少，比如一位数从0开始，2位数从10开始</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(n &gt; i * s)&#123;</span><br><span class="line">            n -=i * s;</span><br><span class="line">            i++;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt; i - r; j++) number /= <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-41-数据流中的中位数-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a> ★</h3>
<h3 id="剑指-Offer-45-把数组排成最小的数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h3>
<blockquote>
<p>难的是背后的数学证明</p>
<p>重新定义排序规则  a &lt; b  &lt;===&gt;  ab &lt; ba</p>
<p>需要证明的是他的反对称性和传递性</p>
<p>证明非常重要</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//static修饰</span></span><br><span class="line">    <span class="comment">//重新定义一个排序规则，若ab &lt; ba , 则 a &lt; b</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> as = <span class="built_in">to_string</span>(a), bs = <span class="built_in">to_string</span>(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//将数组按照特定规则排序 字典序排序 </span></span><br><span class="line">       <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">       string res;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) res += <span class="built_in">to_string</span>(x);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(Nlog^2N)$$</p>
</li>
<li>
<p>空间复杂度：$$O(N)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-46-把数字翻译成字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3>
<blockquote>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imge231fde16304948251633cfc65d04396f117239ea2d13896b1d2678de9067b42-Picture1.png" alt="Picture1.png"></p>
<ul>
<li><strong>初始状态：</strong> dp[0] = dp[1] = 1，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 ；</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">translateNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//定义dp[i]：当数组的长度为i时，有多少种方案</span></span><br><span class="line">        <span class="comment">//求关系式：dp[i] = dp[i-1] + (dp[i-2])</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];        <span class="comment">//第 i 个字符单独作为一个数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//第i-1个字符s[i-2] 和 第 i 个字符s[i-1] 组合</span></span><br><span class="line">            <span class="type">int</span> t = (s[i - <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">            <span class="keyword">if</span> (t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当处于 i - 2时，此时再往下翻译</p>
<ol>
<li>
<p>若 i - 1 和 i 可以联合翻译，则有两种方式翻译，一个是一步一步翻译，一个是后两个一起翻译</p>
<p>所以dp[i] = dp[i - 1] + dp[i - 2]；</p>
</li>
<li>
<p>若 i - 1和 i 不可以联合翻译，则只能一步一步翻译</p>
<p>dp[i - 2] = dp[i - 1] = dp[i]</p>
</li>
</ol>
<p><strong>此题和爬楼梯，青蛙跳台问题思路完全一样</strong></p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p>
<p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTranslationCount</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//dp[i] 表示字符串s中前i位字符串有多少种翻译方式</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//初始化两个数据</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= <span class="number">10</span> &amp;&amp; k &lt;= <span class="number">25</span>) dp[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> t = (s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(n)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-47-礼物的最大价值"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h3>
<blockquote>
<p>dp(i,j)：从棋盘左上角开始，到达单元格（i,j）时能拿到的礼物最大价值</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220825142707496.png" alt="image-20220825142707496"></p>
<p><code>dp[i][j]</code>只与<code>dp[i-1][j]、dp[i][j-1]，grid[i][j]</code>有关，因此可以将原矩阵 grid 用作 dp 矩阵，即直接在 grid 上修改即可。【dp按序更新】空间复杂度O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n =grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一行和第一列只会是原点直接出发横走或竖走到达的，（路径是明确唯一）所以直接可以判断出路径和最大值，是多少没必要进入双层for循环判断</span></span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="comment">//只可能从正上方/正左方过来</span></span><br><span class="line">                grid[i][j] += <span class="built_in">max</span>(grid[i - <span class="number">1</span>][j],grid[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度 $$O(m*n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-48-最长不含重复字符的子字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3>
<blockquote>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220825153855260.png" alt="image-20220825153855260"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//map,根据字符找出下标位置i</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map; <span class="comment">//下标key为字符，值value为该字符的位置。 比如“ab” 的map为 map[a]=0 map[b]=1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//不重复，直接连接dp[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(s[i]) == map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//重复，判断在dp[i-1]内部还是外部，内部重新选取，外部，不影响内部独特性，直接连接</span></span><br><span class="line">                <span class="type">int</span> j =map[s[i]];</span><br><span class="line">                <span class="keyword">if</span>(i - j &gt; dp[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            map[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> max_length = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>双指针算法</p>
<p>双指针i，j维护一段不重复子串</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubstringWithoutDuplication</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//last用来遍历数组的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first = <span class="number">0</span>, last = <span class="number">0</span>; last &lt; s.<span class="built_in">size</span>(); last++)&#123;</span><br><span class="line">            hash[s[last]] ++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[last]] &gt; <span class="number">1</span>) hash[s[first++]]--;</span><br><span class="line">            res = <span class="built_in">max</span>(res, last - first + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$，其中 n 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
</li>
<li>
<p>空间复杂度：$$O(K)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-49-丑数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h3>
<blockquote>
S$$ = 1	2	3	4	5	6	8	9	10	12

$$S_2$$ = 2	4	6	8	10	12	14...

$$S_3$$ = 3	6	9	12	15	18...

$$S_5$$ = 5	10	15	20	25...

**关系**

S = $${1} \cup {S_2} \cup{S_3} \cup{S_5}$$ 排序并去重

$$S = S_2/2
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>S</mi><mn>3</mn></msub><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">S = S_3/3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/3</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><msub><mi>S</mi><mn>5</mn></msub><mi mathvariant="normal">/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">S = S_5/5
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/5</span></span></span></span></span></p>
<p>三路归并</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;   <span class="comment">//第一个丑数1</span></span><br><span class="line">          <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>( -- n)&#123;     <span class="comment">//执行 n-1次  </span></span><br><span class="line">              <span class="comment">//三路各自假设迈出一步，取其中最小的加入丑数队列中</span></span><br><span class="line">              <span class="type">int</span> t = <span class="built_in">min</span>(q[i] * <span class="number">2</span>,<span class="built_in">min</span>(q[j] * <span class="number">3</span>,q[k] * <span class="number">5</span>)); </span><br><span class="line">              q.<span class="built_in">push_back</span>(t);   <span class="comment">//vector自动扩容</span></span><br><span class="line">              <span class="comment">//判断是哪一路迈出的，指针++，可能有多路都同时迈出，则都++</span></span><br><span class="line">              <span class="keyword">if</span>(t == q[i] * <span class="number">2</span>) i++;</span><br><span class="line">              <span class="keyword">if</span>(t == q[j] * <span class="number">3</span>) j++;</span><br><span class="line">              <span class="keyword">if</span>(t == q[k] * <span class="number">5</span>) k++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> q.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$，</p>
</li>
<li>
<p>空间复杂度：$$O(n)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-50-第一个只出现一次的字符"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstUniqChar</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: s) map[c]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c :s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map[c] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$，</p>
</li>
<li>
<p>空间复杂度：$$O(n)$$</p>
</li>
</ul>
<h3 id="字符流中第一个只出现一次的字符"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/60/">字符流中第一个只出现一次的字符</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">    queue&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当一个字符第一次从字符流中读出来，把他保存到队列中</span></span><br><span class="line">        <span class="keyword">if</span>(++ count[ch] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//队列中永远保持不重复</span></span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; count[q.<span class="built_in">front</span>()] &gt; <span class="number">1</span>) q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-51-数组中的逆序对-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a> ★</h3>
<p>题目的主要信息：</p>
<ul>
<li>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。</li>
<li>输入一个数组，求一个数组的全部逆序对，答案对1000000007取模</li>
<li>保证输入的数组中没有的相同的数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) cnt ++;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：$$O(n)$$ TEL</p>
<blockquote>
<p>归并排序</p>
<p>如下图所示，为数组 [7, 3, 2, 6, 0, 1, 5, 4][7,3,2,6,0,1,5,4] 的归并排序过程。</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20221018164028130.png" alt="image-20221018164028130" style="zoom:50%;">
<p>因为我们在归并排序过程中会将数组划分成最小为2个元素的子数组，然后依次比较子数组的长度，这里我们也可以用相同的方法统计逆序对。我们主要有三个阶段：</p>
<ul>
<li>step 1： 划分阶段：将待划分区间从中点划分成两部分；</li>
<li>step 2： 排序阶段：使用归并排序递归地处理子序列，<strong>同时统计逆序对</strong>；</li>
<li>step 3： 合并阶段：将排好序的子序列合并，同时累加逆序对。</li>
</ul>
<p>因为在归并排序中，右边大于左边时，它大于了左边的所有子序列，基于这个性质我们可以不用每次加1来统计，减少运算次数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">inversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将原来的归并排序代码返回值void改成int</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">         <span class="comment">//确定分界点</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">merge_sort</span>(nums, l, mid) + <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//归并</span></span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;  <span class="comment">//划分的两个子数组</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;      <span class="comment">//被赋值的新数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) tmp.<span class="built_in">push_back</span>(nums[i ++]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[j++]);</span><br><span class="line">                res += mid - i + <span class="number">1</span>;         <span class="comment">//这里就是逆序对的统计</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) tmp.<span class="built_in">push_back</span>(nums[i ++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) tmp.<span class="built_in">push_back</span>(nums[j ++]);</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="comment">//传进来的q数组的左右边界下标是l,r;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp) nums[i++] = x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(nlog_2n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(n)$$，辅助数组temp长度为$$n$$及递归栈最大深度不会超过$$n$$</p>
</li>
</ul>
<h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;     <span class="comment">//可能是最后空节点，所以p、q都要走到空节点，把不相交的情况也包含进来了</span></span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA;</span><br><span class="line">        <span class="keyword">auto</span> q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;next)&#123;          <span class="comment">//无法排除两个链表不相交的情况</span></span><br><span class="line">                p = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!q-&gt;next)&#123;</span><br><span class="line">                q = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h3>
<blockquote>
<p>二分查找的应用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums , <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        target = k;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">l_search</span>(nums);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">r_search</span>(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找第一个&gt;=target的数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] == target) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最后一个&lt;=于target的数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">r_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] == target) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(log_2n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220825194334703.png" alt="image-20220825194334703" style="zoom:50%;">
<p>二分查找的应用<br>
注意特殊情况：当所有数都满足<code>nums[i] == i</code>时，表示缺失的是 n。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] != mid) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] != l) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(log_2n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="数组中数值和下标相等的元素"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/65/">数组中数值和下标相等的元素</a></h3>
<blockquote>
<p><strong>题目描述</strong></p>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。</p>
<p>请编程实现一个函数找出数组中任意一个数值等于其下标的元素。</p>
<p>例如，在数组 [−3,−1,1,3,5][−3,−1,1,3,5] 中，数字 33 和它的下标相等。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//数值 &lt;= 坐标====&gt;右区间查找</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= mid) l = mid; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] == l) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(log_2n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3>
<blockquote>
<p>第k大的节点，也就是从小到大排序，第K个数</p>
<p>利用二叉搜索树中序遍历，顺便记录一下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">          <span class="built_in">dfs</span>(root, k);</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,k);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) ans = root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-55-I-二叉树的深度"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h3>
<blockquote>
<ul>
<li>
<p><strong>关键点：</strong> 此树的深度和其左（右）子树的深度之间的关系。显然，<strong>此树的深度</strong> 等于 <strong>左子树的深度</strong> 与 <strong>右子树的深度</strong> 中的 <strong>最大值</strong> +1 。</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220826085546969.png" alt="image-20220826085546969"></p>
</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(l,r);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果为空节点的话，就返回0，表示高度为0</span></span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">max</span>(l, r) + <span class="number">1</span>;  <span class="comment">// +1 是因为算上当前节点 </span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-55-II-平衡二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer 55 - II. 平衡二叉树</a></h3>
<blockquote>
<p>在遍历二叉树深度的函数中，添加一个辅助变量，实时统计每个节点是否平衡</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>时间复杂度：$$O(n)$$</p>
</li>
<li>
<p>空间复杂度：$$O(1)$$</p>
</li>
</ul>
<h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3>
<p>题目主要信息：</p>
<ul>
<li>一个长度为的数字，除了两个数字只出现1次，其余数字都出现2次</li>
<li>要找到这两次只出现一次的数字，还要以非降序输出</li>
</ul>
<blockquote>
<ol>
<li>
<p>哈希表</p>
</li>
<li>
<h5 id="异或运算（位运算）">异或运算（位运算）</h5>
<ul>
<li>
<p>两个相同的数异或为0</p>
</li>
<li>
<p>如果题目换成&quot;数组中只出现一次的一个数字&quot;==&gt;直接将所有数据异或操作，得出结果；</p>
<p>那么，出现两个数字怎么做呢？===&gt; 考虑如何将这两个数字分到两个组中，这样两个组分别异或，就会各自得出1个数字-----&gt;<strong>怎么分成两组是关键</strong></p>
</li>
<li>
<p>还有一个隐含信息：两个不同的数的二进制形式，最少有一位是不同的，那么一定有一个是0，一个是1，异或后的结果中该位对应的就是1</p>
</li>
<li>
<p>一个整数sum通过二进制的方式找出某一个为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++   <span class="comment">//k就是对应的位数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一个整数sum通过二进制的方式判断第k位是否为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt;&gt; k &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>本题主要考察如何节省空间，时间最少都得遍历一遍O(n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       	<span class="comment">// 1、遍历数组得到a^b</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) sum ^= num;  <span class="comment">//sum一定有一位是1</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2、找到两个数不相同的第一位==&gt;即倒数第一个为1的数的位置</span></span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3、遍历数组，对每个数分类，并求出只出现1次的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;&gt; k &amp; <span class="number">1</span>) x ^= num;     <span class="comment">//k位为1</span></span><br><span class="line">            <span class="keyword">else</span> y ^= num;         <span class="comment">//k位 为 0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，遍历两次数组，找到两个数不相同的第一位循环为常数次</li>
<li>空间复杂度：$$O(1)$$，无额外空间使用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></p>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png" alt="Picture1.png" style="zoom:50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> two = <span class="number">0</span>, one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: nums) &#123;</span><br><span class="line">            <span class="comment">//构造函数，欣赏就好</span></span><br><span class="line">            one = (one ^ x) &amp; ~two;</span><br><span class="line">            two = (two ^ x) &amp; ~one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-57-和为s的两个数字"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h3>
<blockquote>
<p>有序的，直接双指针</p>
<p>无序的，需要用到hash表、set几何</p>
<p>如<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">两数之和–返回下标</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;      <span class="comment">//&lt;nums[i], i&gt;</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">         <span class="keyword">auto</span> num = target - nums[i];</span><br><span class="line">         <span class="keyword">if</span>(hash.<span class="built_in">find</span>(num) != hash.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;i, hash[num]&#125;;  <span class="comment">//find函数</span></span><br><span class="line">         hash[nums[i]] = i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/71/">两数之和–返回值</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">     unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">         <span class="keyword">if</span>(hash.<span class="built_in">count</span>(target - x)) <span class="keyword">return</span> &#123;x, target - x&#125;;</span><br><span class="line">         hash.<span class="built_in">insert</span>(x);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] &gt; target) j --;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target) i ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;nums[i],nums[j]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;nums[i],nums[j]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3>
<blockquote>
<p>滑动窗口：</p>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/img1611495306-LsrxgS-Picture2.png" alt="Picture2.png" style="zoom:25%;">
<p>输入一个非负整数 S，打印出所有和为 S 的连续正数序列（至少含有两个数）。</p>
<p>例如输入 15，由于 1+2+3+4+5=4+5+6=7+8=15，所以结果打印出 3 个连续序列 1∼5、4∼6 和 7∼8。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findContinuousSequence</span>(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>, sum = <span class="number">3</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">             <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                sum -= i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                sum += ++j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(k);</span><br><span class="line">                res.<span class="built_in">push_back</span>(ans);</span><br><span class="line">                sum -= i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-58-I-翻转单词顺序-重要"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a> (重要)</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(s[j] != <span class="string">&#x27; &#x27;</span> &amp;&amp; j &lt; s.<span class="built_in">size</span>()) j++;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<blockquote>
<p>包含前导零，单词之间多个零，结尾多个零</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/imgimage-20220622104923200.png" alt="image-20220622104923200"></p>
<ol>
<li>
<p>过滤空格（前导、中间）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤前导空格/中间多余空格</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>找出连续非空----翻转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找一段连续的字符串，并且翻转</span></span><br><span class="line">           <span class="type">int</span> j = i;</span><br><span class="line">           <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">           <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j); <span class="comment">//包括左区间指向的元素，不包括右区间指向的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>存入实际的字符串</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//过滤前导空格/中间多余空格</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">            <span class="keyword">if</span>(i == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//寻找一段连续的字符串，并且翻转</span></span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);  <span class="comment">//包括左区间指向的元素，不包括右区间指向的元素</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment">//将连续的字符串存入实际的字符串中，注意空格的添加判断</span></span><br><span class="line">            <span class="keyword">if</span>(k) s[k++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j) s[k++] = s[i++]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉尾部空格</span></span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<blockquote>
<p>从后向前遍历</p>
<p>不是内外两次反转</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//去除前导零，后缀零</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= i; )&#123;</span><br><span class="line">            <span class="comment">//寻找连续一段非零</span></span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= i &amp;&amp; s[k] != <span class="string">&#x27; &#x27;</span>) k--;</span><br><span class="line">            <span class="comment">//添加到新的字符串 + &quot; &quot;</span></span><br><span class="line">            res += s.<span class="built_in">substr</span>(k + <span class="number">1</span>, j - k);</span><br><span class="line">            res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//跳过一段连续非零</span></span><br><span class="line">            j = k;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= i &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">substr</span>(<span class="number">0</span>, res.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(n)$$，</li>
</ul>
<h3 id="剑指-Offer-58-II-左旋转字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(n,s.<span class="built_in">size</span>()-n) + s.<span class="built_in">substr</span>(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - n );</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-offer61-扑克牌中的顺子"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 offer61. 扑克牌中的顺子</a></h3>
<blockquote>
<ul>
<li>先对数组执行排序。</li>
<li>去除元素为0的元素</li>
<li>从第一个非零的元素进行判重操作</li>
<li>最大值与最小值比较 &lt;= 4</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStraight</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[k] == <span class="number">0</span>) k++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">back</span>() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(nlog_2n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-62-圆圈中最后剩下的数字-★"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a> ★</h3>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/ic234-q2-ex11.png" alt="img" style="zoom:50%;">
<blockquote>
<p>上述问题建模为函数 <code>f(n, m)</code>，该函数的返回值为最终留下的元素的序号。</p>
<p>首先，长度为 n 的序列会先删除第 <code>m % n</code> 个元素，然后剩下一个长度为<code>n - 1</code>的序列。那么，我们可以递归地求解<code>f(n - 1, m)</code>，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 对应的答案 x 之后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有</p>
<p><code> f(n, m) = (m % n + x) % n = (m + x) % n</code>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>数学+递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">lastRemaining</span>(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，需要求解的函数有n个</li>
<li>空间复杂度：$$O(n)$$，函数的递归深度为 n，需要使用 O(n) 的栈空间。</li>
</ul>
<p><strong>数学 + 迭代</strong></p>
<blockquote>
<p>正向推导过程: 约瑟夫环最后一个人的下标,一定是0(只剩一个人活着了),这点都能理解 所以从0推导</p>
<ol>
<li>一个人的时候: 这个活着的人的下标是0. 所以需要知道当两个人存在的时候,这个人的下标是多少;</li>
<li>两个人的时候: 这个活着的人下标:(0+3)%2=1 所以需要知道当三个人存在的时候 ,这个人的下标是多少;</li>
<li>三个人的时候: 这个活着的人下标:(1+3)%3=1 所以需要知道当四个人存在的时候 ,这个人的下标是多少;</li>
<li>主要是公式f(n,m)=(x+m)%n 的理解,这个x到底指的是什么; 指的是在下一轮报数,那个活着人的下标:我们唯一知道的是最终活着的人的下标是0</li>
<li>f(n,m)=( f(n-1,m)+m)%n 是第一轮报数,这个活着人的下标; 但是需要知道这个人在第二轮的下标 f(n-1,m),才能推出第一轮报数的下标</li>
<li>f(n-1,m)=(f(n-2,m)+m)%n 是第二轮报数, 这个活着人的下标;</li>
<li>…</li>
<li>最后一轮报数 f(2,m)=(f(1,m)+m)%n=(0+m)%n</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>;  <span class="comment">//一个人的话，存活的下边为0,</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i != n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            f = (f + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，需要求解的函数有n个</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-63-股票的最大利润"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h3>
<p><strong>贪心</strong></p>
<blockquote>
<p>因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = INT_MAX;   <span class="comment">//保持i左边的最小值</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;        <span class="comment">//维持i左边的最大价值/差值</span></span><br><span class="line">        <span class="comment">//直接枚举在哪一天卖</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
<h3 id="剑指-Offer-64-求1-2-…-n"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof/">剑指 Offer 64. 求1+2+…+n</a></h3>
<blockquote>
<p>语法题</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = n;</span><br><span class="line">        <span class="comment">// if(n &gt; 0)</span></span><br><span class="line">        n &gt; <span class="number">0</span> &amp;&amp; (res += <span class="built_in">getSum</span>(n - <span class="number">1</span>));  <span class="comment">// 短路作用</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，不考虑系统栈</li>
</ul>
<h3 id="剑指-Offer-66-构建乘积数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组</a></h3>
<blockquote>
<img src="/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/image-20221118222155548-16687813172313.png" alt="image-20221118222155548" style="zoom: 67%;">
<ul>
<li>初始化：数组B ，其中 B[0]=1 ；辅助变量 tmp = 1 ；</li>
<li>计算 B[i] 的下三角 各元素的乘积，直接乘入 B[i]；</li>
<li>计算 B[i] 的上三角 各元素的乘积，记为 tmptmp ，并乘入 B[i]；</li>
<li>返回 B。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算左下角</span></span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            B[i] = p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算右上角</span></span><br><span class="line">        p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            B[i] *= p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：$$O(n)$$，</li>
<li>空间复杂度：$$O(1)$$，</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://hupingsheng.com">huxianseng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hupingsheng.com/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/">http://hupingsheng.com/算法/剑指offer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hupingsheng.com" target="_blank">胡大仙</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/post_images/jianzhi-offer.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/" title="二叉树系列"><img class="cover" src="/post_images/jianzhi-offer.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉树系列</div></div></a></div><div class="next-post pull-right"><a href="/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针"><img class="cover" src="/post_images/jianzhi-offer.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">双指针</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/" title="回溯专题"><img class="cover" src="/images/home.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-16</div><div class="title">回溯专题</div></div></a></div><div><a href="/%E7%AE%97%E6%B3%95/acwing/" title="acwing"><img class="cover" src="/post_images/acwing.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-19</div><div class="title">acwing</div></div></a></div><div><a href="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8E%92%E5%BA%8F%E7%B3%BB%E5%88%97/" title="二分查找 &amp;&amp; 排序专题"><img class="cover" src="/post_images/jianzhi-offer.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">二分查找 &amp;&amp; 排序专题</div></div></a></div><div><a href="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97/" title="二叉树系列"><img class="cover" src="/post_images/jianzhi-offer.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">二叉树系列</div></div></a></div><div><a href="/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/" title="双指针"><img class="cover" src="/post_images/jianzhi-offer.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">双指针</div></div></a></div><div><a href="/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><img class="cover" src="/post_images/jianzhi-offer.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">动态规划</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">huxianseng</div><div class="author-info__description">日拱一卒，功不唐捐!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hupingsheng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hupingsheng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hu942658636@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E2%98%85"><span class="toc-number">1.</span> <span class="toc-text">剑指 Offer 03. 数组中重复的数字★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">不修改数组找出重复的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E2%98%85"><span class="toc-number">3.</span> <span class="toc-text">剑指 Offer 04. 二维数组中的查找★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">4.</span> <span class="toc-text">剑指 Offer 05. 替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%E2%98%85"><span class="toc-number">5.</span> <span class="toc-text">剑指 Offer 06. 从尾到头打印链表★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E2%98%85"><span class="toc-number">6.</span> <span class="toc-text">剑指 Offer 07. 重建二叉树★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E2%98%85"><span class="toc-number">7.</span> <span class="toc-text">剑指 Offer 09. 用两个栈实现队列★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">剑指 Offer 10- I. 斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">剑指 Offer 10- II. 青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%E2%98%85"><span class="toc-number">10.</span> <span class="toc-text">剑指 Offer 11. 旋转数组的最小数字★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E2%98%85"><span class="toc-number">11.</span> <span class="toc-text">剑指 Offer 12. 矩阵中的路径★</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DFS-%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">11.0.1.</span> <span class="toc-text">DFS 解析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">12.</span> <span class="toc-text">剑指 Offer 13. 机器人的运动范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="toc-number">13.</span> <span class="toc-text">剪绳子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">剑指 Offer 15. 二进制中1的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">15.</span> <span class="toc-text">剑指 Offer 16. 数值的整数次方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8O-1-%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">在O(1)时间删除链表节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">剑指 Offer 17. 打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9-%E2%98%85"><span class="toc-number">19.</span> <span class="toc-text">删除链表重复节点 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">20.</span> <span class="toc-text">剑指 Offer 19. 正则表达式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">21.</span> <span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">22.</span> <span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-II-022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">23.</span> <span class="toc-text">剑指 Offer II 022. 链表中环的入口节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">24.</span> <span class="toc-text">剑指 Offer 24. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B1-%E6%AF%94%E8%BE%83%E6%98%8E%E6%98%BE%E7%9A%84%E8%83%BD%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">24.0.1.</span> <span class="toc-text">例1: (比较明显的能递推公式的问题)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">25.</span> <span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">26.</span> <span class="toc-text">剑指 Offer 26. 树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">27.</span> <span class="toc-text">剑指 Offer 27. 二叉树的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">28.</span> <span class="toc-text">剑指 Offer 28. 对称的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">29.</span> <span class="toc-text">剑指 Offer 29. 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">30.</span> <span class="toc-text">剑指 Offer 30. 包含min函数的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">31.</span> <span class="toc-text">剑指 Offer 31. 栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">32.</span> <span class="toc-text">剑指 Offer 32 - I. 从上到下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II"><span class="toc-number">33.</span> <span class="toc-text">剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="toc-number">34.</span> <span class="toc-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">35.</span> <span class="toc-text">剑指 Offer 33. 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E2%98%85"><span class="toc-number">36.</span> <span class="toc-text">剑指 Offer 34. 二叉树中和为某一值的路径 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6-%E2%98%85"><span class="toc-number">37.</span> <span class="toc-text">剑指 Offer 35. 复杂链表的复制 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">38.</span> <span class="toc-text">剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91-%E2%98%85"><span class="toc-number">39.</span> <span class="toc-text">剑指 Offer 37. 序列化二叉树 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%85%A8%E6%8E%92%E5%88%97-%E2%98%85"><span class="toc-number">40.</span> <span class="toc-text">数字全排列 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">41.</span> <span class="toc-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">42.</span> <span class="toc-text">剑指 Offer 40. 最小的k个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">43.</span> <span class="toc-text">剑指 Offer 42. 连续子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E2%98%85"><span class="toc-number">44.</span> <span class="toc-text">剑指 Offer 44. 数字序列中某一位的数字 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E2%98%85"><span class="toc-number">45.</span> <span class="toc-text">剑指 Offer 41. 数据流中的中位数 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">46.</span> <span class="toc-text">剑指 Offer 45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">47.</span> <span class="toc-text">剑指 Offer 46. 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">48.</span> <span class="toc-text">剑指 Offer 47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">49.</span> <span class="toc-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0"><span class="toc-number">50.</span> <span class="toc-text">剑指 Offer 49. 丑数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">51.</span> <span class="toc-text">剑指 Offer 50. 第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">52.</span> <span class="toc-text">字符流中第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9-%E2%98%85"><span class="toc-number">53.</span> <span class="toc-text">剑指 Offer 51. 数组中的逆序对 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">54.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I"><span class="toc-number">55.</span> <span class="toc-text">剑指 Offer 53 - I. 在排序数组中查找数字 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">56.</span> <span class="toc-text">剑指 Offer 53 - II. 0～n-1中缺失的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">57.</span> <span class="toc-text">数组中数值和下标相等的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">58.</span> <span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">59.</span> <span class="toc-text">剑指 Offer 55 - I. 二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">60.</span> <span class="toc-text">剑指 Offer 55 - II. 平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">61.</span> <span class="toc-text">剑指 Offer 56 - I. 数组中数字出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">61.0.1.</span> <span class="toc-text">异或运算（位运算）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">62.</span> <span class="toc-text">剑指 Offer 57. 和为s的两个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">63.</span> <span class="toc-text">剑指 Offer 57 - II. 和为s的连续正数序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F-%E9%87%8D%E8%A6%81"><span class="toc-number">64.</span> <span class="toc-text">剑指 Offer 58 - I. 翻转单词顺序 (重要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">65.</span> <span class="toc-text">剑指 Offer 58 - II. 左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">66.</span> <span class="toc-text">剑指 offer61. 扑克牌中的顺子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97-%E2%98%85"><span class="toc-number">67.</span> <span class="toc-text">剑指 Offer 62. 圆圈中最后剩下的数字 ★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">68.</span> <span class="toc-text">剑指 Offer 63. 股票的最大利润</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n"><span class="toc-number">69.</span> <span class="toc-text">剑指 Offer 64. 求1+2+…+n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-number">70.</span> <span class="toc-text">剑指 Offer 66. 构建乘积数组</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法题"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法题"/></a><div class="content"><a class="title" href="/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" title="算法题">算法题</a><time datetime="2023-08-31T02:47:33.000Z" title="发表于 2023-08-31 10:47:33">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/RDB%E5%92%8CAOF/" title="Redis持久化"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis持久化"/></a><div class="content"><a class="title" href="/RDB%E5%92%8CAOF/" title="Redis持久化">Redis持久化</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/JUC/" title="JUC学习笔记"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUC学习笔记"/></a><div class="content"><a class="title" href="/JUC/" title="JUC学习笔记">JUC学习笔记</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2/" title="创建菜单和游戏界面"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建菜单和游戏界面"/></a><div class="content"><a class="title" href="/%E5%88%9B%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%92%8C%E6%B8%B8%E6%88%8F%E7%95%8C%E9%9D%A2/" title="创建菜单和游戏界面">创建菜单和游戏界面</a><time datetime="2023-08-26T13:23:19.000Z" title="发表于 2023-08-26 21:23:19">2023-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/" title="缓存更新方案"><img src="/images/home.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="缓存更新方案"/></a><div class="content"><a class="title" href="/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/" title="缓存更新方案">缓存更新方案</a><time datetime="2023-08-13T07:15:26.000Z" title="发表于 2023-08-13 15:15:26">2023-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By huxianseng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>